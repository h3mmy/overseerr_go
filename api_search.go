/*
Overseerr API

This is the documentation for the Overseerr API backend.  Two primary authentication methods are supported:  - **Cookie Authentication**: A valid sign-in to the `/auth/plex` or `/auth/local` will generate a valid authentication cookie. - **API Key Authentication**: Sign-in is also possible by passing an `X-Api-Key` header along with a valid API Key generated by Overseerr. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type SearchAPI interface {

	/*
	DiscoverGenresliderMovieGet Get genre slider data for movies

	Returns a list of genres with backdrops attached

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SearchAPIDiscoverGenresliderMovieGetRequest
	*/
	DiscoverGenresliderMovieGet(ctx context.Context) SearchAPIDiscoverGenresliderMovieGetRequest

	// DiscoverGenresliderMovieGetExecute executes the request
	//  @return []DiscoverGenresliderMovieGet200ResponseInner
	DiscoverGenresliderMovieGetExecute(r SearchAPIDiscoverGenresliderMovieGetRequest) ([]DiscoverGenresliderMovieGet200ResponseInner, *http.Response, error)

	/*
	DiscoverGenresliderTvGet Get genre slider data for TV series

	Returns a list of genres with backdrops attached

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SearchAPIDiscoverGenresliderTvGetRequest
	*/
	DiscoverGenresliderTvGet(ctx context.Context) SearchAPIDiscoverGenresliderTvGetRequest

	// DiscoverGenresliderTvGetExecute executes the request
	//  @return []DiscoverGenresliderMovieGet200ResponseInner
	DiscoverGenresliderTvGetExecute(r SearchAPIDiscoverGenresliderTvGetRequest) ([]DiscoverGenresliderMovieGet200ResponseInner, *http.Response, error)

	/*
	DiscoverKeywordKeywordIdMoviesGet Get movies from keyword

	Returns list of movies based on the provided keyword ID a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param keywordId
	@return SearchAPIDiscoverKeywordKeywordIdMoviesGetRequest
	*/
	DiscoverKeywordKeywordIdMoviesGet(ctx context.Context, keywordId float32) SearchAPIDiscoverKeywordKeywordIdMoviesGetRequest

	// DiscoverKeywordKeywordIdMoviesGetExecute executes the request
	//  @return DiscoverMoviesGet200Response
	DiscoverKeywordKeywordIdMoviesGetExecute(r SearchAPIDiscoverKeywordKeywordIdMoviesGetRequest) (*DiscoverMoviesGet200Response, *http.Response, error)

	/*
	DiscoverMoviesGenreGenreIdGet Discover movies by genre

	Returns a list of movies based on the provided genre ID in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param genreId
	@return SearchAPIDiscoverMoviesGenreGenreIdGetRequest
	*/
	DiscoverMoviesGenreGenreIdGet(ctx context.Context, genreId string) SearchAPIDiscoverMoviesGenreGenreIdGetRequest

	// DiscoverMoviesGenreGenreIdGetExecute executes the request
	//  @return DiscoverMoviesGenreGenreIdGet200Response
	DiscoverMoviesGenreGenreIdGetExecute(r SearchAPIDiscoverMoviesGenreGenreIdGetRequest) (*DiscoverMoviesGenreGenreIdGet200Response, *http.Response, error)

	/*
	DiscoverMoviesGet Discover movies

	Returns a list of movies in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SearchAPIDiscoverMoviesGetRequest
	*/
	DiscoverMoviesGet(ctx context.Context) SearchAPIDiscoverMoviesGetRequest

	// DiscoverMoviesGetExecute executes the request
	//  @return DiscoverMoviesGet200Response
	DiscoverMoviesGetExecute(r SearchAPIDiscoverMoviesGetRequest) (*DiscoverMoviesGet200Response, *http.Response, error)

	/*
	DiscoverMoviesLanguageLanguageGet Discover movies by original language

	Returns a list of movies based on the provided ISO 639-1 language code in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param language
	@return SearchAPIDiscoverMoviesLanguageLanguageGetRequest
	*/
	DiscoverMoviesLanguageLanguageGet(ctx context.Context, language string) SearchAPIDiscoverMoviesLanguageLanguageGetRequest

	// DiscoverMoviesLanguageLanguageGetExecute executes the request
	//  @return DiscoverMoviesLanguageLanguageGet200Response
	DiscoverMoviesLanguageLanguageGetExecute(r SearchAPIDiscoverMoviesLanguageLanguageGetRequest) (*DiscoverMoviesLanguageLanguageGet200Response, *http.Response, error)

	/*
	DiscoverMoviesStudioStudioIdGet Discover movies by studio

	Returns a list of movies based on the provided studio ID in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param studioId
	@return SearchAPIDiscoverMoviesStudioStudioIdGetRequest
	*/
	DiscoverMoviesStudioStudioIdGet(ctx context.Context, studioId string) SearchAPIDiscoverMoviesStudioStudioIdGetRequest

	// DiscoverMoviesStudioStudioIdGetExecute executes the request
	//  @return DiscoverMoviesStudioStudioIdGet200Response
	DiscoverMoviesStudioStudioIdGetExecute(r SearchAPIDiscoverMoviesStudioStudioIdGetRequest) (*DiscoverMoviesStudioStudioIdGet200Response, *http.Response, error)

	/*
	DiscoverMoviesUpcomingGet Upcoming movies

	Returns a list of movies in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SearchAPIDiscoverMoviesUpcomingGetRequest
	*/
	DiscoverMoviesUpcomingGet(ctx context.Context) SearchAPIDiscoverMoviesUpcomingGetRequest

	// DiscoverMoviesUpcomingGetExecute executes the request
	//  @return DiscoverMoviesGet200Response
	DiscoverMoviesUpcomingGetExecute(r SearchAPIDiscoverMoviesUpcomingGetRequest) (*DiscoverMoviesGet200Response, *http.Response, error)

	/*
	DiscoverTrendingGet Trending movies and TV

	Returns a list of movies and TV shows in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SearchAPIDiscoverTrendingGetRequest
	*/
	DiscoverTrendingGet(ctx context.Context) SearchAPIDiscoverTrendingGetRequest

	// DiscoverTrendingGetExecute executes the request
	//  @return SearchGet200Response
	DiscoverTrendingGetExecute(r SearchAPIDiscoverTrendingGetRequest) (*SearchGet200Response, *http.Response, error)

	/*
	DiscoverTvGenreGenreIdGet Discover TV shows by genre

	Returns a list of TV shows based on the provided genre ID in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param genreId
	@return SearchAPIDiscoverTvGenreGenreIdGetRequest
	*/
	DiscoverTvGenreGenreIdGet(ctx context.Context, genreId string) SearchAPIDiscoverTvGenreGenreIdGetRequest

	// DiscoverTvGenreGenreIdGetExecute executes the request
	//  @return DiscoverTvGenreGenreIdGet200Response
	DiscoverTvGenreGenreIdGetExecute(r SearchAPIDiscoverTvGenreGenreIdGetRequest) (*DiscoverTvGenreGenreIdGet200Response, *http.Response, error)

	/*
	DiscoverTvGet Discover TV shows

	Returns a list of TV shows in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SearchAPIDiscoverTvGetRequest
	*/
	DiscoverTvGet(ctx context.Context) SearchAPIDiscoverTvGetRequest

	// DiscoverTvGetExecute executes the request
	//  @return DiscoverTvGet200Response
	DiscoverTvGetExecute(r SearchAPIDiscoverTvGetRequest) (*DiscoverTvGet200Response, *http.Response, error)

	/*
	DiscoverTvLanguageLanguageGet Discover TV shows by original language

	Returns a list of TV shows based on the provided ISO 639-1 language code in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param language
	@return SearchAPIDiscoverTvLanguageLanguageGetRequest
	*/
	DiscoverTvLanguageLanguageGet(ctx context.Context, language string) SearchAPIDiscoverTvLanguageLanguageGetRequest

	// DiscoverTvLanguageLanguageGetExecute executes the request
	//  @return DiscoverTvLanguageLanguageGet200Response
	DiscoverTvLanguageLanguageGetExecute(r SearchAPIDiscoverTvLanguageLanguageGetRequest) (*DiscoverTvLanguageLanguageGet200Response, *http.Response, error)

	/*
	DiscoverTvNetworkNetworkIdGet Discover TV shows by network

	Returns a list of TV shows based on the provided network ID in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param networkId
	@return SearchAPIDiscoverTvNetworkNetworkIdGetRequest
	*/
	DiscoverTvNetworkNetworkIdGet(ctx context.Context, networkId string) SearchAPIDiscoverTvNetworkNetworkIdGetRequest

	// DiscoverTvNetworkNetworkIdGetExecute executes the request
	//  @return DiscoverTvNetworkNetworkIdGet200Response
	DiscoverTvNetworkNetworkIdGetExecute(r SearchAPIDiscoverTvNetworkNetworkIdGetRequest) (*DiscoverTvNetworkNetworkIdGet200Response, *http.Response, error)

	/*
	DiscoverTvUpcomingGet Discover Upcoming TV shows

	Returns a list of upcoming TV shows in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SearchAPIDiscoverTvUpcomingGetRequest
	*/
	DiscoverTvUpcomingGet(ctx context.Context) SearchAPIDiscoverTvUpcomingGetRequest

	// DiscoverTvUpcomingGetExecute executes the request
	//  @return DiscoverTvGet200Response
	DiscoverTvUpcomingGetExecute(r SearchAPIDiscoverTvUpcomingGetRequest) (*DiscoverTvGet200Response, *http.Response, error)

	/*
	DiscoverWatchlistGet Get the Plex watchlist.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SearchAPIDiscoverWatchlistGetRequest
	*/
	DiscoverWatchlistGet(ctx context.Context) SearchAPIDiscoverWatchlistGetRequest

	// DiscoverWatchlistGetExecute executes the request
	//  @return UserUserIdWatchlistGet200Response
	DiscoverWatchlistGetExecute(r SearchAPIDiscoverWatchlistGetRequest) (*UserUserIdWatchlistGet200Response, *http.Response, error)

	/*
	SearchCompanyGet Search for companies

	Returns a list of TMDB companies matching the search query. (Will not return origin country)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SearchAPISearchCompanyGetRequest
	*/
	SearchCompanyGet(ctx context.Context) SearchAPISearchCompanyGetRequest

	// SearchCompanyGetExecute executes the request
	//  @return SearchCompanyGet200Response
	SearchCompanyGetExecute(r SearchAPISearchCompanyGetRequest) (*SearchCompanyGet200Response, *http.Response, error)

	/*
	SearchGet Search for movies, TV shows, or people

	Returns a list of movies, TV shows, or people a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SearchAPISearchGetRequest
	*/
	SearchGet(ctx context.Context) SearchAPISearchGetRequest

	// SearchGetExecute executes the request
	//  @return SearchGet200Response
	SearchGetExecute(r SearchAPISearchGetRequest) (*SearchGet200Response, *http.Response, error)

	/*
	SearchKeywordGet Search for keywords

	Returns a list of TMDB keywords matching the search query

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SearchAPISearchKeywordGetRequest
	*/
	SearchKeywordGet(ctx context.Context) SearchAPISearchKeywordGetRequest

	// SearchKeywordGetExecute executes the request
	//  @return SearchKeywordGet200Response
	SearchKeywordGetExecute(r SearchAPISearchKeywordGetRequest) (*SearchKeywordGet200Response, *http.Response, error)
}

// SearchAPIService SearchAPI service
type SearchAPIService service

type SearchAPIDiscoverGenresliderMovieGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	language *string
}

func (r SearchAPIDiscoverGenresliderMovieGetRequest) Language(language string) SearchAPIDiscoverGenresliderMovieGetRequest {
	r.language = &language
	return r
}

func (r SearchAPIDiscoverGenresliderMovieGetRequest) Execute() ([]DiscoverGenresliderMovieGet200ResponseInner, *http.Response, error) {
	return r.ApiService.DiscoverGenresliderMovieGetExecute(r)
}

/*
DiscoverGenresliderMovieGet Get genre slider data for movies

Returns a list of genres with backdrops attached

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SearchAPIDiscoverGenresliderMovieGetRequest
*/
func (a *SearchAPIService) DiscoverGenresliderMovieGet(ctx context.Context) SearchAPIDiscoverGenresliderMovieGetRequest {
	return SearchAPIDiscoverGenresliderMovieGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DiscoverGenresliderMovieGet200ResponseInner
func (a *SearchAPIService) DiscoverGenresliderMovieGetExecute(r SearchAPIDiscoverGenresliderMovieGetRequest) ([]DiscoverGenresliderMovieGet200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DiscoverGenresliderMovieGet200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.DiscoverGenresliderMovieGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/genreslider/movie"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPIDiscoverGenresliderTvGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	language *string
}

func (r SearchAPIDiscoverGenresliderTvGetRequest) Language(language string) SearchAPIDiscoverGenresliderTvGetRequest {
	r.language = &language
	return r
}

func (r SearchAPIDiscoverGenresliderTvGetRequest) Execute() ([]DiscoverGenresliderMovieGet200ResponseInner, *http.Response, error) {
	return r.ApiService.DiscoverGenresliderTvGetExecute(r)
}

/*
DiscoverGenresliderTvGet Get genre slider data for TV series

Returns a list of genres with backdrops attached

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SearchAPIDiscoverGenresliderTvGetRequest
*/
func (a *SearchAPIService) DiscoverGenresliderTvGet(ctx context.Context) SearchAPIDiscoverGenresliderTvGetRequest {
	return SearchAPIDiscoverGenresliderTvGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DiscoverGenresliderMovieGet200ResponseInner
func (a *SearchAPIService) DiscoverGenresliderTvGetExecute(r SearchAPIDiscoverGenresliderTvGetRequest) ([]DiscoverGenresliderMovieGet200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DiscoverGenresliderMovieGet200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.DiscoverGenresliderTvGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/genreslider/tv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPIDiscoverKeywordKeywordIdMoviesGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	keywordId float32
	page *float32
	language *string
}

func (r SearchAPIDiscoverKeywordKeywordIdMoviesGetRequest) Page(page float32) SearchAPIDiscoverKeywordKeywordIdMoviesGetRequest {
	r.page = &page
	return r
}

func (r SearchAPIDiscoverKeywordKeywordIdMoviesGetRequest) Language(language string) SearchAPIDiscoverKeywordKeywordIdMoviesGetRequest {
	r.language = &language
	return r
}

func (r SearchAPIDiscoverKeywordKeywordIdMoviesGetRequest) Execute() (*DiscoverMoviesGet200Response, *http.Response, error) {
	return r.ApiService.DiscoverKeywordKeywordIdMoviesGetExecute(r)
}

/*
DiscoverKeywordKeywordIdMoviesGet Get movies from keyword

Returns list of movies based on the provided keyword ID a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param keywordId
 @return SearchAPIDiscoverKeywordKeywordIdMoviesGetRequest
*/
func (a *SearchAPIService) DiscoverKeywordKeywordIdMoviesGet(ctx context.Context, keywordId float32) SearchAPIDiscoverKeywordKeywordIdMoviesGetRequest {
	return SearchAPIDiscoverKeywordKeywordIdMoviesGetRequest{
		ApiService: a,
		ctx: ctx,
		keywordId: keywordId,
	}
}

// Execute executes the request
//  @return DiscoverMoviesGet200Response
func (a *SearchAPIService) DiscoverKeywordKeywordIdMoviesGetExecute(r SearchAPIDiscoverKeywordKeywordIdMoviesGetRequest) (*DiscoverMoviesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscoverMoviesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.DiscoverKeywordKeywordIdMoviesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/keyword/{keywordId}/movies"
	localVarPath = strings.Replace(localVarPath, "{"+"keywordId"+"}", url.PathEscape(parameterValueToString(r.keywordId, "keywordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPIDiscoverMoviesGenreGenreIdGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	genreId string
	page *float32
	language *string
}

func (r SearchAPIDiscoverMoviesGenreGenreIdGetRequest) Page(page float32) SearchAPIDiscoverMoviesGenreGenreIdGetRequest {
	r.page = &page
	return r
}

func (r SearchAPIDiscoverMoviesGenreGenreIdGetRequest) Language(language string) SearchAPIDiscoverMoviesGenreGenreIdGetRequest {
	r.language = &language
	return r
}

func (r SearchAPIDiscoverMoviesGenreGenreIdGetRequest) Execute() (*DiscoverMoviesGenreGenreIdGet200Response, *http.Response, error) {
	return r.ApiService.DiscoverMoviesGenreGenreIdGetExecute(r)
}

/*
DiscoverMoviesGenreGenreIdGet Discover movies by genre

Returns a list of movies based on the provided genre ID in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param genreId
 @return SearchAPIDiscoverMoviesGenreGenreIdGetRequest
*/
func (a *SearchAPIService) DiscoverMoviesGenreGenreIdGet(ctx context.Context, genreId string) SearchAPIDiscoverMoviesGenreGenreIdGetRequest {
	return SearchAPIDiscoverMoviesGenreGenreIdGetRequest{
		ApiService: a,
		ctx: ctx,
		genreId: genreId,
	}
}

// Execute executes the request
//  @return DiscoverMoviesGenreGenreIdGet200Response
func (a *SearchAPIService) DiscoverMoviesGenreGenreIdGetExecute(r SearchAPIDiscoverMoviesGenreGenreIdGetRequest) (*DiscoverMoviesGenreGenreIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscoverMoviesGenreGenreIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.DiscoverMoviesGenreGenreIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/movies/genre/{genreId}"
	localVarPath = strings.Replace(localVarPath, "{"+"genreId"+"}", url.PathEscape(parameterValueToString(r.genreId, "genreId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPIDiscoverMoviesGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	page *float32
	language *string
	genre *string
	studio *float32
	keywords *string
	sortBy *string
	primaryReleaseDateGte *string
	primaryReleaseDateLte *string
	withRuntimeGte *float32
	withRuntimeLte *float32
	voteAverageGte *float32
	voteAverageLte *float32
	voteCountGte *float32
	voteCountLte *float32
	watchRegion *string
	watchProviders *string
}

func (r SearchAPIDiscoverMoviesGetRequest) Page(page float32) SearchAPIDiscoverMoviesGetRequest {
	r.page = &page
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) Language(language string) SearchAPIDiscoverMoviesGetRequest {
	r.language = &language
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) Genre(genre string) SearchAPIDiscoverMoviesGetRequest {
	r.genre = &genre
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) Studio(studio float32) SearchAPIDiscoverMoviesGetRequest {
	r.studio = &studio
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) Keywords(keywords string) SearchAPIDiscoverMoviesGetRequest {
	r.keywords = &keywords
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) SortBy(sortBy string) SearchAPIDiscoverMoviesGetRequest {
	r.sortBy = &sortBy
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) PrimaryReleaseDateGte(primaryReleaseDateGte string) SearchAPIDiscoverMoviesGetRequest {
	r.primaryReleaseDateGte = &primaryReleaseDateGte
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) PrimaryReleaseDateLte(primaryReleaseDateLte string) SearchAPIDiscoverMoviesGetRequest {
	r.primaryReleaseDateLte = &primaryReleaseDateLte
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) WithRuntimeGte(withRuntimeGte float32) SearchAPIDiscoverMoviesGetRequest {
	r.withRuntimeGte = &withRuntimeGte
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) WithRuntimeLte(withRuntimeLte float32) SearchAPIDiscoverMoviesGetRequest {
	r.withRuntimeLte = &withRuntimeLte
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) VoteAverageGte(voteAverageGte float32) SearchAPIDiscoverMoviesGetRequest {
	r.voteAverageGte = &voteAverageGte
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) VoteAverageLte(voteAverageLte float32) SearchAPIDiscoverMoviesGetRequest {
	r.voteAverageLte = &voteAverageLte
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) VoteCountGte(voteCountGte float32) SearchAPIDiscoverMoviesGetRequest {
	r.voteCountGte = &voteCountGte
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) VoteCountLte(voteCountLte float32) SearchAPIDiscoverMoviesGetRequest {
	r.voteCountLte = &voteCountLte
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) WatchRegion(watchRegion string) SearchAPIDiscoverMoviesGetRequest {
	r.watchRegion = &watchRegion
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) WatchProviders(watchProviders string) SearchAPIDiscoverMoviesGetRequest {
	r.watchProviders = &watchProviders
	return r
}

func (r SearchAPIDiscoverMoviesGetRequest) Execute() (*DiscoverMoviesGet200Response, *http.Response, error) {
	return r.ApiService.DiscoverMoviesGetExecute(r)
}

/*
DiscoverMoviesGet Discover movies

Returns a list of movies in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SearchAPIDiscoverMoviesGetRequest
*/
func (a *SearchAPIService) DiscoverMoviesGet(ctx context.Context) SearchAPIDiscoverMoviesGetRequest {
	return SearchAPIDiscoverMoviesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DiscoverMoviesGet200Response
func (a *SearchAPIService) DiscoverMoviesGetExecute(r SearchAPIDiscoverMoviesGetRequest) (*DiscoverMoviesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscoverMoviesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.DiscoverMoviesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/movies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	if r.genre != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "genre", r.genre, "")
	}
	if r.studio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "studio", r.studio, "")
	}
	if r.keywords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keywords", r.keywords, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.primaryReleaseDateGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryReleaseDateGte", r.primaryReleaseDateGte, "")
	}
	if r.primaryReleaseDateLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryReleaseDateLte", r.primaryReleaseDateLte, "")
	}
	if r.withRuntimeGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withRuntimeGte", r.withRuntimeGte, "")
	}
	if r.withRuntimeLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withRuntimeLte", r.withRuntimeLte, "")
	}
	if r.voteAverageGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "voteAverageGte", r.voteAverageGte, "")
	}
	if r.voteAverageLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "voteAverageLte", r.voteAverageLte, "")
	}
	if r.voteCountGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "voteCountGte", r.voteCountGte, "")
	}
	if r.voteCountLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "voteCountLte", r.voteCountLte, "")
	}
	if r.watchRegion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "watchRegion", r.watchRegion, "")
	}
	if r.watchProviders != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "watchProviders", r.watchProviders, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPIDiscoverMoviesLanguageLanguageGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	language string
	page *float32
	language2 *string
}

func (r SearchAPIDiscoverMoviesLanguageLanguageGetRequest) Page(page float32) SearchAPIDiscoverMoviesLanguageLanguageGetRequest {
	r.page = &page
	return r
}

func (r SearchAPIDiscoverMoviesLanguageLanguageGetRequest) Language2(language2 string) SearchAPIDiscoverMoviesLanguageLanguageGetRequest {
	r.language2 = &language2
	return r
}

func (r SearchAPIDiscoverMoviesLanguageLanguageGetRequest) Execute() (*DiscoverMoviesLanguageLanguageGet200Response, *http.Response, error) {
	return r.ApiService.DiscoverMoviesLanguageLanguageGetExecute(r)
}

/*
DiscoverMoviesLanguageLanguageGet Discover movies by original language

Returns a list of movies based on the provided ISO 639-1 language code in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param language
 @return SearchAPIDiscoverMoviesLanguageLanguageGetRequest
*/
func (a *SearchAPIService) DiscoverMoviesLanguageLanguageGet(ctx context.Context, language string) SearchAPIDiscoverMoviesLanguageLanguageGetRequest {
	return SearchAPIDiscoverMoviesLanguageLanguageGetRequest{
		ApiService: a,
		ctx: ctx,
		language: language,
	}
}

// Execute executes the request
//  @return DiscoverMoviesLanguageLanguageGet200Response
func (a *SearchAPIService) DiscoverMoviesLanguageLanguageGetExecute(r SearchAPIDiscoverMoviesLanguageLanguageGetRequest) (*DiscoverMoviesLanguageLanguageGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscoverMoviesLanguageLanguageGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.DiscoverMoviesLanguageLanguageGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/movies/language/{language}"
	localVarPath = strings.Replace(localVarPath, "{"+"language"+"}", url.PathEscape(parameterValueToString(r.language, "language")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	if r.language2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language2, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPIDiscoverMoviesStudioStudioIdGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	studioId string
	page *float32
	language *string
}

func (r SearchAPIDiscoverMoviesStudioStudioIdGetRequest) Page(page float32) SearchAPIDiscoverMoviesStudioStudioIdGetRequest {
	r.page = &page
	return r
}

func (r SearchAPIDiscoverMoviesStudioStudioIdGetRequest) Language(language string) SearchAPIDiscoverMoviesStudioStudioIdGetRequest {
	r.language = &language
	return r
}

func (r SearchAPIDiscoverMoviesStudioStudioIdGetRequest) Execute() (*DiscoverMoviesStudioStudioIdGet200Response, *http.Response, error) {
	return r.ApiService.DiscoverMoviesStudioStudioIdGetExecute(r)
}

/*
DiscoverMoviesStudioStudioIdGet Discover movies by studio

Returns a list of movies based on the provided studio ID in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param studioId
 @return SearchAPIDiscoverMoviesStudioStudioIdGetRequest
*/
func (a *SearchAPIService) DiscoverMoviesStudioStudioIdGet(ctx context.Context, studioId string) SearchAPIDiscoverMoviesStudioStudioIdGetRequest {
	return SearchAPIDiscoverMoviesStudioStudioIdGetRequest{
		ApiService: a,
		ctx: ctx,
		studioId: studioId,
	}
}

// Execute executes the request
//  @return DiscoverMoviesStudioStudioIdGet200Response
func (a *SearchAPIService) DiscoverMoviesStudioStudioIdGetExecute(r SearchAPIDiscoverMoviesStudioStudioIdGetRequest) (*DiscoverMoviesStudioStudioIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscoverMoviesStudioStudioIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.DiscoverMoviesStudioStudioIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/movies/studio/{studioId}"
	localVarPath = strings.Replace(localVarPath, "{"+"studioId"+"}", url.PathEscape(parameterValueToString(r.studioId, "studioId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPIDiscoverMoviesUpcomingGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	page *float32
	language *string
}

func (r SearchAPIDiscoverMoviesUpcomingGetRequest) Page(page float32) SearchAPIDiscoverMoviesUpcomingGetRequest {
	r.page = &page
	return r
}

func (r SearchAPIDiscoverMoviesUpcomingGetRequest) Language(language string) SearchAPIDiscoverMoviesUpcomingGetRequest {
	r.language = &language
	return r
}

func (r SearchAPIDiscoverMoviesUpcomingGetRequest) Execute() (*DiscoverMoviesGet200Response, *http.Response, error) {
	return r.ApiService.DiscoverMoviesUpcomingGetExecute(r)
}

/*
DiscoverMoviesUpcomingGet Upcoming movies

Returns a list of movies in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SearchAPIDiscoverMoviesUpcomingGetRequest
*/
func (a *SearchAPIService) DiscoverMoviesUpcomingGet(ctx context.Context) SearchAPIDiscoverMoviesUpcomingGetRequest {
	return SearchAPIDiscoverMoviesUpcomingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DiscoverMoviesGet200Response
func (a *SearchAPIService) DiscoverMoviesUpcomingGetExecute(r SearchAPIDiscoverMoviesUpcomingGetRequest) (*DiscoverMoviesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscoverMoviesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.DiscoverMoviesUpcomingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/movies/upcoming"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPIDiscoverTrendingGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	page *float32
	language *string
}

func (r SearchAPIDiscoverTrendingGetRequest) Page(page float32) SearchAPIDiscoverTrendingGetRequest {
	r.page = &page
	return r
}

func (r SearchAPIDiscoverTrendingGetRequest) Language(language string) SearchAPIDiscoverTrendingGetRequest {
	r.language = &language
	return r
}

func (r SearchAPIDiscoverTrendingGetRequest) Execute() (*SearchGet200Response, *http.Response, error) {
	return r.ApiService.DiscoverTrendingGetExecute(r)
}

/*
DiscoverTrendingGet Trending movies and TV

Returns a list of movies and TV shows in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SearchAPIDiscoverTrendingGetRequest
*/
func (a *SearchAPIService) DiscoverTrendingGet(ctx context.Context) SearchAPIDiscoverTrendingGetRequest {
	return SearchAPIDiscoverTrendingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchGet200Response
func (a *SearchAPIService) DiscoverTrendingGetExecute(r SearchAPIDiscoverTrendingGetRequest) (*SearchGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.DiscoverTrendingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/trending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPIDiscoverTvGenreGenreIdGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	genreId string
	page *float32
	language *string
}

func (r SearchAPIDiscoverTvGenreGenreIdGetRequest) Page(page float32) SearchAPIDiscoverTvGenreGenreIdGetRequest {
	r.page = &page
	return r
}

func (r SearchAPIDiscoverTvGenreGenreIdGetRequest) Language(language string) SearchAPIDiscoverTvGenreGenreIdGetRequest {
	r.language = &language
	return r
}

func (r SearchAPIDiscoverTvGenreGenreIdGetRequest) Execute() (*DiscoverTvGenreGenreIdGet200Response, *http.Response, error) {
	return r.ApiService.DiscoverTvGenreGenreIdGetExecute(r)
}

/*
DiscoverTvGenreGenreIdGet Discover TV shows by genre

Returns a list of TV shows based on the provided genre ID in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param genreId
 @return SearchAPIDiscoverTvGenreGenreIdGetRequest
*/
func (a *SearchAPIService) DiscoverTvGenreGenreIdGet(ctx context.Context, genreId string) SearchAPIDiscoverTvGenreGenreIdGetRequest {
	return SearchAPIDiscoverTvGenreGenreIdGetRequest{
		ApiService: a,
		ctx: ctx,
		genreId: genreId,
	}
}

// Execute executes the request
//  @return DiscoverTvGenreGenreIdGet200Response
func (a *SearchAPIService) DiscoverTvGenreGenreIdGetExecute(r SearchAPIDiscoverTvGenreGenreIdGetRequest) (*DiscoverTvGenreGenreIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscoverTvGenreGenreIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.DiscoverTvGenreGenreIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/tv/genre/{genreId}"
	localVarPath = strings.Replace(localVarPath, "{"+"genreId"+"}", url.PathEscape(parameterValueToString(r.genreId, "genreId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPIDiscoverTvGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	page *float32
	language *string
	genre *string
	network *float32
	keywords *string
	sortBy *string
	firstAirDateGte *string
	firstAirDateLte *string
	withRuntimeGte *float32
	withRuntimeLte *float32
	voteAverageGte *float32
	voteAverageLte *float32
	voteCountGte *float32
	voteCountLte *float32
	watchRegion *string
	watchProviders *string
}

func (r SearchAPIDiscoverTvGetRequest) Page(page float32) SearchAPIDiscoverTvGetRequest {
	r.page = &page
	return r
}

func (r SearchAPIDiscoverTvGetRequest) Language(language string) SearchAPIDiscoverTvGetRequest {
	r.language = &language
	return r
}

func (r SearchAPIDiscoverTvGetRequest) Genre(genre string) SearchAPIDiscoverTvGetRequest {
	r.genre = &genre
	return r
}

func (r SearchAPIDiscoverTvGetRequest) Network(network float32) SearchAPIDiscoverTvGetRequest {
	r.network = &network
	return r
}

func (r SearchAPIDiscoverTvGetRequest) Keywords(keywords string) SearchAPIDiscoverTvGetRequest {
	r.keywords = &keywords
	return r
}

func (r SearchAPIDiscoverTvGetRequest) SortBy(sortBy string) SearchAPIDiscoverTvGetRequest {
	r.sortBy = &sortBy
	return r
}

func (r SearchAPIDiscoverTvGetRequest) FirstAirDateGte(firstAirDateGte string) SearchAPIDiscoverTvGetRequest {
	r.firstAirDateGte = &firstAirDateGte
	return r
}

func (r SearchAPIDiscoverTvGetRequest) FirstAirDateLte(firstAirDateLte string) SearchAPIDiscoverTvGetRequest {
	r.firstAirDateLte = &firstAirDateLte
	return r
}

func (r SearchAPIDiscoverTvGetRequest) WithRuntimeGte(withRuntimeGte float32) SearchAPIDiscoverTvGetRequest {
	r.withRuntimeGte = &withRuntimeGte
	return r
}

func (r SearchAPIDiscoverTvGetRequest) WithRuntimeLte(withRuntimeLte float32) SearchAPIDiscoverTvGetRequest {
	r.withRuntimeLte = &withRuntimeLte
	return r
}

func (r SearchAPIDiscoverTvGetRequest) VoteAverageGte(voteAverageGte float32) SearchAPIDiscoverTvGetRequest {
	r.voteAverageGte = &voteAverageGte
	return r
}

func (r SearchAPIDiscoverTvGetRequest) VoteAverageLte(voteAverageLte float32) SearchAPIDiscoverTvGetRequest {
	r.voteAverageLte = &voteAverageLte
	return r
}

func (r SearchAPIDiscoverTvGetRequest) VoteCountGte(voteCountGte float32) SearchAPIDiscoverTvGetRequest {
	r.voteCountGte = &voteCountGte
	return r
}

func (r SearchAPIDiscoverTvGetRequest) VoteCountLte(voteCountLte float32) SearchAPIDiscoverTvGetRequest {
	r.voteCountLte = &voteCountLte
	return r
}

func (r SearchAPIDiscoverTvGetRequest) WatchRegion(watchRegion string) SearchAPIDiscoverTvGetRequest {
	r.watchRegion = &watchRegion
	return r
}

func (r SearchAPIDiscoverTvGetRequest) WatchProviders(watchProviders string) SearchAPIDiscoverTvGetRequest {
	r.watchProviders = &watchProviders
	return r
}

func (r SearchAPIDiscoverTvGetRequest) Execute() (*DiscoverTvGet200Response, *http.Response, error) {
	return r.ApiService.DiscoverTvGetExecute(r)
}

/*
DiscoverTvGet Discover TV shows

Returns a list of TV shows in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SearchAPIDiscoverTvGetRequest
*/
func (a *SearchAPIService) DiscoverTvGet(ctx context.Context) SearchAPIDiscoverTvGetRequest {
	return SearchAPIDiscoverTvGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DiscoverTvGet200Response
func (a *SearchAPIService) DiscoverTvGetExecute(r SearchAPIDiscoverTvGetRequest) (*DiscoverTvGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscoverTvGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.DiscoverTvGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/tv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	if r.genre != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "genre", r.genre, "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "")
	}
	if r.keywords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keywords", r.keywords, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.firstAirDateGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstAirDateGte", r.firstAirDateGte, "")
	}
	if r.firstAirDateLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstAirDateLte", r.firstAirDateLte, "")
	}
	if r.withRuntimeGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withRuntimeGte", r.withRuntimeGte, "")
	}
	if r.withRuntimeLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withRuntimeLte", r.withRuntimeLte, "")
	}
	if r.voteAverageGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "voteAverageGte", r.voteAverageGte, "")
	}
	if r.voteAverageLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "voteAverageLte", r.voteAverageLte, "")
	}
	if r.voteCountGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "voteCountGte", r.voteCountGte, "")
	}
	if r.voteCountLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "voteCountLte", r.voteCountLte, "")
	}
	if r.watchRegion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "watchRegion", r.watchRegion, "")
	}
	if r.watchProviders != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "watchProviders", r.watchProviders, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPIDiscoverTvLanguageLanguageGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	language string
	page *float32
	language2 *string
}

func (r SearchAPIDiscoverTvLanguageLanguageGetRequest) Page(page float32) SearchAPIDiscoverTvLanguageLanguageGetRequest {
	r.page = &page
	return r
}

func (r SearchAPIDiscoverTvLanguageLanguageGetRequest) Language2(language2 string) SearchAPIDiscoverTvLanguageLanguageGetRequest {
	r.language2 = &language2
	return r
}

func (r SearchAPIDiscoverTvLanguageLanguageGetRequest) Execute() (*DiscoverTvLanguageLanguageGet200Response, *http.Response, error) {
	return r.ApiService.DiscoverTvLanguageLanguageGetExecute(r)
}

/*
DiscoverTvLanguageLanguageGet Discover TV shows by original language

Returns a list of TV shows based on the provided ISO 639-1 language code in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param language
 @return SearchAPIDiscoverTvLanguageLanguageGetRequest
*/
func (a *SearchAPIService) DiscoverTvLanguageLanguageGet(ctx context.Context, language string) SearchAPIDiscoverTvLanguageLanguageGetRequest {
	return SearchAPIDiscoverTvLanguageLanguageGetRequest{
		ApiService: a,
		ctx: ctx,
		language: language,
	}
}

// Execute executes the request
//  @return DiscoverTvLanguageLanguageGet200Response
func (a *SearchAPIService) DiscoverTvLanguageLanguageGetExecute(r SearchAPIDiscoverTvLanguageLanguageGetRequest) (*DiscoverTvLanguageLanguageGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscoverTvLanguageLanguageGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.DiscoverTvLanguageLanguageGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/tv/language/{language}"
	localVarPath = strings.Replace(localVarPath, "{"+"language"+"}", url.PathEscape(parameterValueToString(r.language, "language")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	if r.language2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language2, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPIDiscoverTvNetworkNetworkIdGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	networkId string
	page *float32
	language *string
}

func (r SearchAPIDiscoverTvNetworkNetworkIdGetRequest) Page(page float32) SearchAPIDiscoverTvNetworkNetworkIdGetRequest {
	r.page = &page
	return r
}

func (r SearchAPIDiscoverTvNetworkNetworkIdGetRequest) Language(language string) SearchAPIDiscoverTvNetworkNetworkIdGetRequest {
	r.language = &language
	return r
}

func (r SearchAPIDiscoverTvNetworkNetworkIdGetRequest) Execute() (*DiscoverTvNetworkNetworkIdGet200Response, *http.Response, error) {
	return r.ApiService.DiscoverTvNetworkNetworkIdGetExecute(r)
}

/*
DiscoverTvNetworkNetworkIdGet Discover TV shows by network

Returns a list of TV shows based on the provided network ID in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId
 @return SearchAPIDiscoverTvNetworkNetworkIdGetRequest
*/
func (a *SearchAPIService) DiscoverTvNetworkNetworkIdGet(ctx context.Context, networkId string) SearchAPIDiscoverTvNetworkNetworkIdGetRequest {
	return SearchAPIDiscoverTvNetworkNetworkIdGetRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return DiscoverTvNetworkNetworkIdGet200Response
func (a *SearchAPIService) DiscoverTvNetworkNetworkIdGetExecute(r SearchAPIDiscoverTvNetworkNetworkIdGetRequest) (*DiscoverTvNetworkNetworkIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscoverTvNetworkNetworkIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.DiscoverTvNetworkNetworkIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/tv/network/{networkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterValueToString(r.networkId, "networkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPIDiscoverTvUpcomingGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	page *float32
	language *string
}

func (r SearchAPIDiscoverTvUpcomingGetRequest) Page(page float32) SearchAPIDiscoverTvUpcomingGetRequest {
	r.page = &page
	return r
}

func (r SearchAPIDiscoverTvUpcomingGetRequest) Language(language string) SearchAPIDiscoverTvUpcomingGetRequest {
	r.language = &language
	return r
}

func (r SearchAPIDiscoverTvUpcomingGetRequest) Execute() (*DiscoverTvGet200Response, *http.Response, error) {
	return r.ApiService.DiscoverTvUpcomingGetExecute(r)
}

/*
DiscoverTvUpcomingGet Discover Upcoming TV shows

Returns a list of upcoming TV shows in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SearchAPIDiscoverTvUpcomingGetRequest
*/
func (a *SearchAPIService) DiscoverTvUpcomingGet(ctx context.Context) SearchAPIDiscoverTvUpcomingGetRequest {
	return SearchAPIDiscoverTvUpcomingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DiscoverTvGet200Response
func (a *SearchAPIService) DiscoverTvUpcomingGetExecute(r SearchAPIDiscoverTvUpcomingGetRequest) (*DiscoverTvGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscoverTvGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.DiscoverTvUpcomingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/tv/upcoming"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPIDiscoverWatchlistGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	page *float32
}

func (r SearchAPIDiscoverWatchlistGetRequest) Page(page float32) SearchAPIDiscoverWatchlistGetRequest {
	r.page = &page
	return r
}

func (r SearchAPIDiscoverWatchlistGetRequest) Execute() (*UserUserIdWatchlistGet200Response, *http.Response, error) {
	return r.ApiService.DiscoverWatchlistGetExecute(r)
}

/*
DiscoverWatchlistGet Get the Plex watchlist.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SearchAPIDiscoverWatchlistGetRequest
*/
func (a *SearchAPIService) DiscoverWatchlistGet(ctx context.Context) SearchAPIDiscoverWatchlistGetRequest {
	return SearchAPIDiscoverWatchlistGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserUserIdWatchlistGet200Response
func (a *SearchAPIService) DiscoverWatchlistGetExecute(r SearchAPIDiscoverWatchlistGetRequest) (*UserUserIdWatchlistGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserUserIdWatchlistGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.DiscoverWatchlistGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/watchlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPISearchCompanyGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	query *string
	page *float32
}

func (r SearchAPISearchCompanyGetRequest) Query(query string) SearchAPISearchCompanyGetRequest {
	r.query = &query
	return r
}

func (r SearchAPISearchCompanyGetRequest) Page(page float32) SearchAPISearchCompanyGetRequest {
	r.page = &page
	return r
}

func (r SearchAPISearchCompanyGetRequest) Execute() (*SearchCompanyGet200Response, *http.Response, error) {
	return r.ApiService.SearchCompanyGetExecute(r)
}

/*
SearchCompanyGet Search for companies

Returns a list of TMDB companies matching the search query. (Will not return origin country)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SearchAPISearchCompanyGetRequest
*/
func (a *SearchAPIService) SearchCompanyGet(ctx context.Context) SearchAPISearchCompanyGetRequest {
	return SearchAPISearchCompanyGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchCompanyGet200Response
func (a *SearchAPIService) SearchCompanyGetExecute(r SearchAPISearchCompanyGetRequest) (*SearchCompanyGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchCompanyGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.SearchCompanyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/search/company"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPISearchGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	query *string
	page *float32
	language *string
}

func (r SearchAPISearchGetRequest) Query(query string) SearchAPISearchGetRequest {
	r.query = &query
	return r
}

func (r SearchAPISearchGetRequest) Page(page float32) SearchAPISearchGetRequest {
	r.page = &page
	return r
}

func (r SearchAPISearchGetRequest) Language(language string) SearchAPISearchGetRequest {
	r.language = &language
	return r
}

func (r SearchAPISearchGetRequest) Execute() (*SearchGet200Response, *http.Response, error) {
	return r.ApiService.SearchGetExecute(r)
}

/*
SearchGet Search for movies, TV shows, or people

Returns a list of movies, TV shows, or people a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SearchAPISearchGetRequest
*/
func (a *SearchAPIService) SearchGet(ctx context.Context) SearchAPISearchGetRequest {
	return SearchAPISearchGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchGet200Response
func (a *SearchAPIService) SearchGetExecute(r SearchAPISearchGetRequest) (*SearchGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.SearchGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchAPISearchKeywordGetRequest struct {
	ctx context.Context
	ApiService SearchAPI
	query *string
	page *float32
}

func (r SearchAPISearchKeywordGetRequest) Query(query string) SearchAPISearchKeywordGetRequest {
	r.query = &query
	return r
}

func (r SearchAPISearchKeywordGetRequest) Page(page float32) SearchAPISearchKeywordGetRequest {
	r.page = &page
	return r
}

func (r SearchAPISearchKeywordGetRequest) Execute() (*SearchKeywordGet200Response, *http.Response, error) {
	return r.ApiService.SearchKeywordGetExecute(r)
}

/*
SearchKeywordGet Search for keywords

Returns a list of TMDB keywords matching the search query

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SearchAPISearchKeywordGetRequest
*/
func (a *SearchAPIService) SearchKeywordGet(ctx context.Context) SearchAPISearchKeywordGetRequest {
	return SearchAPISearchKeywordGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchKeywordGet200Response
func (a *SearchAPIService) SearchKeywordGetExecute(r SearchAPISearchKeywordGetRequest) (*SearchKeywordGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchKeywordGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.SearchKeywordGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/search/keyword"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 1
		r.page = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
