/*
Overseerr API

This is the documentation for the Overseerr API backend.  Two primary authentication methods are supported:  - **Cookie Authentication**: A valid sign-in to the `/auth/plex` or `/auth/local` will generate a valid authentication cookie. - **API Key Authentication**: Sign-in is also possible by passing an `X-Api-Key` header along with a valid API Key generated by Overseerr. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type SettingsAPI interface {

	/*
	SettingsAboutGet Get server stats

	Returns current server stats in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsAboutGetRequest
	*/
	SettingsAboutGet(ctx context.Context) SettingsAPISettingsAboutGetRequest

	// SettingsAboutGetExecute executes the request
	//  @return SettingsAboutGet200Response
	SettingsAboutGetExecute(r SettingsAPISettingsAboutGetRequest) (*SettingsAboutGet200Response, *http.Response, error)

	/*
	SettingsCacheCacheIdFlushPost Flush a specific cache

	Flushes all data from the cache ID provided

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param cacheId
	@return SettingsAPISettingsCacheCacheIdFlushPostRequest
	*/
	SettingsCacheCacheIdFlushPost(ctx context.Context, cacheId string) SettingsAPISettingsCacheCacheIdFlushPostRequest

	// SettingsCacheCacheIdFlushPostExecute executes the request
	SettingsCacheCacheIdFlushPostExecute(r SettingsAPISettingsCacheCacheIdFlushPostRequest) (*http.Response, error)

	/*
	SettingsCacheGet Get a list of active caches

	Retrieves a list of all active caches and their current stats.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsCacheGetRequest
	*/
	SettingsCacheGet(ctx context.Context) SettingsAPISettingsCacheGetRequest

	// SettingsCacheGetExecute executes the request
	//  @return SettingsCacheGet200Response
	SettingsCacheGetExecute(r SettingsAPISettingsCacheGetRequest) (*SettingsCacheGet200Response, *http.Response, error)

	/*
	SettingsDiscoverAddPost Add a new slider

	Add a single slider and return the newly created slider. Requires the `ADMIN` permission.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsDiscoverAddPostRequest
	*/
	SettingsDiscoverAddPost(ctx context.Context) SettingsAPISettingsDiscoverAddPostRequest

	// SettingsDiscoverAddPostExecute executes the request
	//  @return DiscoverSlider
	SettingsDiscoverAddPostExecute(r SettingsAPISettingsDiscoverAddPostRequest) (*DiscoverSlider, *http.Response, error)

	/*
	SettingsDiscoverGet Get all discover sliders

	Returns all discovery sliders. Built-in and custom made.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsDiscoverGetRequest
	*/
	SettingsDiscoverGet(ctx context.Context) SettingsAPISettingsDiscoverGetRequest

	// SettingsDiscoverGetExecute executes the request
	//  @return []DiscoverSlider
	SettingsDiscoverGetExecute(r SettingsAPISettingsDiscoverGetRequest) ([]DiscoverSlider, *http.Response, error)

	/*
	SettingsDiscoverPost Batch update all sliders.

	Batch update all sliders at once. Should also be used for creation. Will only update sliders provided
and will not delete any sliders not present in the request. If a slider is missing a required field,
it will be ignored. Requires the `ADMIN` permission.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsDiscoverPostRequest
	*/
	SettingsDiscoverPost(ctx context.Context) SettingsAPISettingsDiscoverPostRequest

	// SettingsDiscoverPostExecute executes the request
	//  @return []DiscoverSlider
	SettingsDiscoverPostExecute(r SettingsAPISettingsDiscoverPostRequest) ([]DiscoverSlider, *http.Response, error)

	/*
	SettingsDiscoverResetGet Reset all discover sliders

	Resets all discovery sliders to the default values. Requires the `ADMIN` permission.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsDiscoverResetGetRequest
	*/
	SettingsDiscoverResetGet(ctx context.Context) SettingsAPISettingsDiscoverResetGetRequest

	// SettingsDiscoverResetGetExecute executes the request
	SettingsDiscoverResetGetExecute(r SettingsAPISettingsDiscoverResetGetRequest) (*http.Response, error)

	/*
	SettingsDiscoverSliderIdDelete Delete slider by ID

	Deletes the slider with the provided sliderId. Requires the `ADMIN` permission.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sliderId
	@return SettingsAPISettingsDiscoverSliderIdDeleteRequest
	*/
	SettingsDiscoverSliderIdDelete(ctx context.Context, sliderId float32) SettingsAPISettingsDiscoverSliderIdDeleteRequest

	// SettingsDiscoverSliderIdDeleteExecute executes the request
	//  @return DiscoverSlider
	SettingsDiscoverSliderIdDeleteExecute(r SettingsAPISettingsDiscoverSliderIdDeleteRequest) (*DiscoverSlider, *http.Response, error)

	/*
	SettingsDiscoverSliderIdPut Update a single slider

	Updates a single slider and return the newly updated slider. Requires the `ADMIN` permission.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsDiscoverSliderIdPutRequest
	*/
	SettingsDiscoverSliderIdPut(ctx context.Context) SettingsAPISettingsDiscoverSliderIdPutRequest

	// SettingsDiscoverSliderIdPutExecute executes the request
	//  @return DiscoverSlider
	SettingsDiscoverSliderIdPutExecute(r SettingsAPISettingsDiscoverSliderIdPutRequest) (*DiscoverSlider, *http.Response, error)

	/*
	SettingsInitializePost Initialize application

	Sets the app as initialized, allowing the user to navigate to pages other than the setup page.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsInitializePostRequest
	*/
	SettingsInitializePost(ctx context.Context) SettingsAPISettingsInitializePostRequest

	// SettingsInitializePostExecute executes the request
	//  @return PublicSettings
	SettingsInitializePostExecute(r SettingsAPISettingsInitializePostRequest) (*PublicSettings, *http.Response, error)

	/*
	SettingsJobsGet Get scheduled jobs

	Returns list of all scheduled jobs and details about their next execution time in a JSON array.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsJobsGetRequest
	*/
	SettingsJobsGet(ctx context.Context) SettingsAPISettingsJobsGetRequest

	// SettingsJobsGetExecute executes the request
	//  @return []Job
	SettingsJobsGetExecute(r SettingsAPISettingsJobsGetRequest) ([]Job, *http.Response, error)

	/*
	SettingsJobsJobIdCancelPost Cancel a specific job

	Cancels a specific job. Will return the new job status in JSON format.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId
	@return SettingsAPISettingsJobsJobIdCancelPostRequest
	*/
	SettingsJobsJobIdCancelPost(ctx context.Context, jobId string) SettingsAPISettingsJobsJobIdCancelPostRequest

	// SettingsJobsJobIdCancelPostExecute executes the request
	//  @return Job
	SettingsJobsJobIdCancelPostExecute(r SettingsAPISettingsJobsJobIdCancelPostRequest) (*Job, *http.Response, error)

	/*
	SettingsJobsJobIdRunPost Invoke a specific job

	Invokes a specific job to run. Will return the new job status in JSON format.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId
	@return SettingsAPISettingsJobsJobIdRunPostRequest
	*/
	SettingsJobsJobIdRunPost(ctx context.Context, jobId string) SettingsAPISettingsJobsJobIdRunPostRequest

	// SettingsJobsJobIdRunPostExecute executes the request
	//  @return Job
	SettingsJobsJobIdRunPostExecute(r SettingsAPISettingsJobsJobIdRunPostRequest) (*Job, *http.Response, error)

	/*
	SettingsJobsJobIdSchedulePost Modify job schedule

	Re-registers the job with the schedule specified. Will return the job in JSON format.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId
	@return SettingsAPISettingsJobsJobIdSchedulePostRequest
	*/
	SettingsJobsJobIdSchedulePost(ctx context.Context, jobId string) SettingsAPISettingsJobsJobIdSchedulePostRequest

	// SettingsJobsJobIdSchedulePostExecute executes the request
	//  @return Job
	SettingsJobsJobIdSchedulePostExecute(r SettingsAPISettingsJobsJobIdSchedulePostRequest) (*Job, *http.Response, error)

	/*
	SettingsLogsGet Returns logs

	Returns list of all log items and details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsLogsGetRequest
	*/
	SettingsLogsGet(ctx context.Context) SettingsAPISettingsLogsGetRequest

	// SettingsLogsGetExecute executes the request
	//  @return []SettingsLogsGet200ResponseInner
	SettingsLogsGetExecute(r SettingsAPISettingsLogsGetRequest) ([]SettingsLogsGet200ResponseInner, *http.Response, error)

	/*
	SettingsMainGet Get main settings

	Retrieves all main settings in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsMainGetRequest
	*/
	SettingsMainGet(ctx context.Context) SettingsAPISettingsMainGetRequest

	// SettingsMainGetExecute executes the request
	//  @return MainSettings
	SettingsMainGetExecute(r SettingsAPISettingsMainGetRequest) (*MainSettings, *http.Response, error)

	/*
	SettingsMainPost Update main settings

	Updates main settings with the provided values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsMainPostRequest
	*/
	SettingsMainPost(ctx context.Context) SettingsAPISettingsMainPostRequest

	// SettingsMainPostExecute executes the request
	//  @return MainSettings
	SettingsMainPostExecute(r SettingsAPISettingsMainPostRequest) (*MainSettings, *http.Response, error)

	/*
	SettingsMainRegeneratePost Get main settings with newly-generated API key

	Returns main settings in a JSON object, using the new API key.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsMainRegeneratePostRequest
	*/
	SettingsMainRegeneratePost(ctx context.Context) SettingsAPISettingsMainRegeneratePostRequest

	// SettingsMainRegeneratePostExecute executes the request
	//  @return MainSettings
	SettingsMainRegeneratePostExecute(r SettingsAPISettingsMainRegeneratePostRequest) (*MainSettings, *http.Response, error)

	/*
	SettingsNotificationsDiscordGet Get Discord notification settings

	Returns current Discord notification settings in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsDiscordGetRequest
	*/
	SettingsNotificationsDiscordGet(ctx context.Context) SettingsAPISettingsNotificationsDiscordGetRequest

	// SettingsNotificationsDiscordGetExecute executes the request
	//  @return DiscordSettings
	SettingsNotificationsDiscordGetExecute(r SettingsAPISettingsNotificationsDiscordGetRequest) (*DiscordSettings, *http.Response, error)

	/*
	SettingsNotificationsDiscordPost Update Discord notification settings

	Updates Discord notification settings with the provided values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsDiscordPostRequest
	*/
	SettingsNotificationsDiscordPost(ctx context.Context) SettingsAPISettingsNotificationsDiscordPostRequest

	// SettingsNotificationsDiscordPostExecute executes the request
	//  @return DiscordSettings
	SettingsNotificationsDiscordPostExecute(r SettingsAPISettingsNotificationsDiscordPostRequest) (*DiscordSettings, *http.Response, error)

	/*
	SettingsNotificationsDiscordTestPost Test Discord settings

	Sends a test notification to the Discord agent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsDiscordTestPostRequest
	*/
	SettingsNotificationsDiscordTestPost(ctx context.Context) SettingsAPISettingsNotificationsDiscordTestPostRequest

	// SettingsNotificationsDiscordTestPostExecute executes the request
	SettingsNotificationsDiscordTestPostExecute(r SettingsAPISettingsNotificationsDiscordTestPostRequest) (*http.Response, error)

	/*
	SettingsNotificationsEmailGet Get email notification settings

	Returns current email notification settings in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsEmailGetRequest
	*/
	SettingsNotificationsEmailGet(ctx context.Context) SettingsAPISettingsNotificationsEmailGetRequest

	// SettingsNotificationsEmailGetExecute executes the request
	//  @return NotificationEmailSettings
	SettingsNotificationsEmailGetExecute(r SettingsAPISettingsNotificationsEmailGetRequest) (*NotificationEmailSettings, *http.Response, error)

	/*
	SettingsNotificationsEmailPost Update email notification settings

	Updates email notification settings with provided values

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsEmailPostRequest
	*/
	SettingsNotificationsEmailPost(ctx context.Context) SettingsAPISettingsNotificationsEmailPostRequest

	// SettingsNotificationsEmailPostExecute executes the request
	//  @return NotificationEmailSettings
	SettingsNotificationsEmailPostExecute(r SettingsAPISettingsNotificationsEmailPostRequest) (*NotificationEmailSettings, *http.Response, error)

	/*
	SettingsNotificationsEmailTestPost Test email settings

	Sends a test notification to the email agent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsEmailTestPostRequest
	*/
	SettingsNotificationsEmailTestPost(ctx context.Context) SettingsAPISettingsNotificationsEmailTestPostRequest

	// SettingsNotificationsEmailTestPostExecute executes the request
	SettingsNotificationsEmailTestPostExecute(r SettingsAPISettingsNotificationsEmailTestPostRequest) (*http.Response, error)

	/*
	SettingsNotificationsGotifyGet Get Gotify notification settings

	Returns current Gotify notification settings in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsGotifyGetRequest
	*/
	SettingsNotificationsGotifyGet(ctx context.Context) SettingsAPISettingsNotificationsGotifyGetRequest

	// SettingsNotificationsGotifyGetExecute executes the request
	//  @return GotifySettings
	SettingsNotificationsGotifyGetExecute(r SettingsAPISettingsNotificationsGotifyGetRequest) (*GotifySettings, *http.Response, error)

	/*
	SettingsNotificationsGotifyPost Update Gotify notification settings

	Update Gotify notification settings with the provided values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsGotifyPostRequest
	*/
	SettingsNotificationsGotifyPost(ctx context.Context) SettingsAPISettingsNotificationsGotifyPostRequest

	// SettingsNotificationsGotifyPostExecute executes the request
	//  @return GotifySettings
	SettingsNotificationsGotifyPostExecute(r SettingsAPISettingsNotificationsGotifyPostRequest) (*GotifySettings, *http.Response, error)

	/*
	SettingsNotificationsGotifyTestPost Test Gotify settings

	Sends a test notification to the Gotify agent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsGotifyTestPostRequest
	*/
	SettingsNotificationsGotifyTestPost(ctx context.Context) SettingsAPISettingsNotificationsGotifyTestPostRequest

	// SettingsNotificationsGotifyTestPostExecute executes the request
	SettingsNotificationsGotifyTestPostExecute(r SettingsAPISettingsNotificationsGotifyTestPostRequest) (*http.Response, error)

	/*
	SettingsNotificationsLunaseaGet Get LunaSea notification settings

	Returns current LunaSea notification settings in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsLunaseaGetRequest
	*/
	SettingsNotificationsLunaseaGet(ctx context.Context) SettingsAPISettingsNotificationsLunaseaGetRequest

	// SettingsNotificationsLunaseaGetExecute executes the request
	//  @return LunaSeaSettings
	SettingsNotificationsLunaseaGetExecute(r SettingsAPISettingsNotificationsLunaseaGetRequest) (*LunaSeaSettings, *http.Response, error)

	/*
	SettingsNotificationsLunaseaPost Update LunaSea notification settings

	Updates LunaSea notification settings with the provided values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsLunaseaPostRequest
	*/
	SettingsNotificationsLunaseaPost(ctx context.Context) SettingsAPISettingsNotificationsLunaseaPostRequest

	// SettingsNotificationsLunaseaPostExecute executes the request
	//  @return LunaSeaSettings
	SettingsNotificationsLunaseaPostExecute(r SettingsAPISettingsNotificationsLunaseaPostRequest) (*LunaSeaSettings, *http.Response, error)

	/*
	SettingsNotificationsLunaseaTestPost Test LunaSea settings

	Sends a test notification to the LunaSea agent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsLunaseaTestPostRequest
	*/
	SettingsNotificationsLunaseaTestPost(ctx context.Context) SettingsAPISettingsNotificationsLunaseaTestPostRequest

	// SettingsNotificationsLunaseaTestPostExecute executes the request
	SettingsNotificationsLunaseaTestPostExecute(r SettingsAPISettingsNotificationsLunaseaTestPostRequest) (*http.Response, error)

	/*
	SettingsNotificationsPushbulletGet Get Pushbullet notification settings

	Returns current Pushbullet notification settings in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsPushbulletGetRequest
	*/
	SettingsNotificationsPushbulletGet(ctx context.Context) SettingsAPISettingsNotificationsPushbulletGetRequest

	// SettingsNotificationsPushbulletGetExecute executes the request
	//  @return PushbulletSettings
	SettingsNotificationsPushbulletGetExecute(r SettingsAPISettingsNotificationsPushbulletGetRequest) (*PushbulletSettings, *http.Response, error)

	/*
	SettingsNotificationsPushbulletPost Update Pushbullet notification settings

	Update Pushbullet notification settings with the provided values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsPushbulletPostRequest
	*/
	SettingsNotificationsPushbulletPost(ctx context.Context) SettingsAPISettingsNotificationsPushbulletPostRequest

	// SettingsNotificationsPushbulletPostExecute executes the request
	//  @return PushbulletSettings
	SettingsNotificationsPushbulletPostExecute(r SettingsAPISettingsNotificationsPushbulletPostRequest) (*PushbulletSettings, *http.Response, error)

	/*
	SettingsNotificationsPushbulletTestPost Test Pushbullet settings

	Sends a test notification to the Pushbullet agent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsPushbulletTestPostRequest
	*/
	SettingsNotificationsPushbulletTestPost(ctx context.Context) SettingsAPISettingsNotificationsPushbulletTestPostRequest

	// SettingsNotificationsPushbulletTestPostExecute executes the request
	SettingsNotificationsPushbulletTestPostExecute(r SettingsAPISettingsNotificationsPushbulletTestPostRequest) (*http.Response, error)

	/*
	SettingsNotificationsPushoverGet Get Pushover notification settings

	Returns current Pushover notification settings in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsPushoverGetRequest
	*/
	SettingsNotificationsPushoverGet(ctx context.Context) SettingsAPISettingsNotificationsPushoverGetRequest

	// SettingsNotificationsPushoverGetExecute executes the request
	//  @return PushoverSettings
	SettingsNotificationsPushoverGetExecute(r SettingsAPISettingsNotificationsPushoverGetRequest) (*PushoverSettings, *http.Response, error)

	/*
	SettingsNotificationsPushoverPost Update Pushover notification settings

	Update Pushover notification settings with the provided values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsPushoverPostRequest
	*/
	SettingsNotificationsPushoverPost(ctx context.Context) SettingsAPISettingsNotificationsPushoverPostRequest

	// SettingsNotificationsPushoverPostExecute executes the request
	//  @return PushoverSettings
	SettingsNotificationsPushoverPostExecute(r SettingsAPISettingsNotificationsPushoverPostRequest) (*PushoverSettings, *http.Response, error)

	/*
	SettingsNotificationsPushoverSoundsGet Get Pushover sounds

	Returns valid Pushover sound options in a JSON array.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsPushoverSoundsGetRequest
	*/
	SettingsNotificationsPushoverSoundsGet(ctx context.Context) SettingsAPISettingsNotificationsPushoverSoundsGetRequest

	// SettingsNotificationsPushoverSoundsGetExecute executes the request
	//  @return []SettingsNotificationsPushoverSoundsGet200ResponseInner
	SettingsNotificationsPushoverSoundsGetExecute(r SettingsAPISettingsNotificationsPushoverSoundsGetRequest) ([]SettingsNotificationsPushoverSoundsGet200ResponseInner, *http.Response, error)

	/*
	SettingsNotificationsPushoverTestPost Test Pushover settings

	Sends a test notification to the Pushover agent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsPushoverTestPostRequest
	*/
	SettingsNotificationsPushoverTestPost(ctx context.Context) SettingsAPISettingsNotificationsPushoverTestPostRequest

	// SettingsNotificationsPushoverTestPostExecute executes the request
	SettingsNotificationsPushoverTestPostExecute(r SettingsAPISettingsNotificationsPushoverTestPostRequest) (*http.Response, error)

	/*
	SettingsNotificationsSlackGet Get Slack notification settings

	Returns current Slack notification settings in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsSlackGetRequest
	*/
	SettingsNotificationsSlackGet(ctx context.Context) SettingsAPISettingsNotificationsSlackGetRequest

	// SettingsNotificationsSlackGetExecute executes the request
	//  @return SlackSettings
	SettingsNotificationsSlackGetExecute(r SettingsAPISettingsNotificationsSlackGetRequest) (*SlackSettings, *http.Response, error)

	/*
	SettingsNotificationsSlackPost Update Slack notification settings

	Updates Slack notification settings with the provided values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsSlackPostRequest
	*/
	SettingsNotificationsSlackPost(ctx context.Context) SettingsAPISettingsNotificationsSlackPostRequest

	// SettingsNotificationsSlackPostExecute executes the request
	//  @return SlackSettings
	SettingsNotificationsSlackPostExecute(r SettingsAPISettingsNotificationsSlackPostRequest) (*SlackSettings, *http.Response, error)

	/*
	SettingsNotificationsSlackTestPost Test Slack settings

	Sends a test notification to the Slack agent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsSlackTestPostRequest
	*/
	SettingsNotificationsSlackTestPost(ctx context.Context) SettingsAPISettingsNotificationsSlackTestPostRequest

	// SettingsNotificationsSlackTestPostExecute executes the request
	SettingsNotificationsSlackTestPostExecute(r SettingsAPISettingsNotificationsSlackTestPostRequest) (*http.Response, error)

	/*
	SettingsNotificationsTelegramGet Get Telegram notification settings

	Returns current Telegram notification settings in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsTelegramGetRequest
	*/
	SettingsNotificationsTelegramGet(ctx context.Context) SettingsAPISettingsNotificationsTelegramGetRequest

	// SettingsNotificationsTelegramGetExecute executes the request
	//  @return TelegramSettings
	SettingsNotificationsTelegramGetExecute(r SettingsAPISettingsNotificationsTelegramGetRequest) (*TelegramSettings, *http.Response, error)

	/*
	SettingsNotificationsTelegramPost Update Telegram notification settings

	Update Telegram notification settings with the provided values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsTelegramPostRequest
	*/
	SettingsNotificationsTelegramPost(ctx context.Context) SettingsAPISettingsNotificationsTelegramPostRequest

	// SettingsNotificationsTelegramPostExecute executes the request
	//  @return TelegramSettings
	SettingsNotificationsTelegramPostExecute(r SettingsAPISettingsNotificationsTelegramPostRequest) (*TelegramSettings, *http.Response, error)

	/*
	SettingsNotificationsTelegramTestPost Test Telegram settings

	Sends a test notification to the Telegram agent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsTelegramTestPostRequest
	*/
	SettingsNotificationsTelegramTestPost(ctx context.Context) SettingsAPISettingsNotificationsTelegramTestPostRequest

	// SettingsNotificationsTelegramTestPostExecute executes the request
	SettingsNotificationsTelegramTestPostExecute(r SettingsAPISettingsNotificationsTelegramTestPostRequest) (*http.Response, error)

	/*
	SettingsNotificationsWebhookGet Get webhook notification settings

	Returns current webhook notification settings in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsWebhookGetRequest
	*/
	SettingsNotificationsWebhookGet(ctx context.Context) SettingsAPISettingsNotificationsWebhookGetRequest

	// SettingsNotificationsWebhookGetExecute executes the request
	//  @return WebhookSettings
	SettingsNotificationsWebhookGetExecute(r SettingsAPISettingsNotificationsWebhookGetRequest) (*WebhookSettings, *http.Response, error)

	/*
	SettingsNotificationsWebhookPost Update webhook notification settings

	Updates webhook notification settings with the provided values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsWebhookPostRequest
	*/
	SettingsNotificationsWebhookPost(ctx context.Context) SettingsAPISettingsNotificationsWebhookPostRequest

	// SettingsNotificationsWebhookPostExecute executes the request
	//  @return WebhookSettings
	SettingsNotificationsWebhookPostExecute(r SettingsAPISettingsNotificationsWebhookPostRequest) (*WebhookSettings, *http.Response, error)

	/*
	SettingsNotificationsWebhookTestPost Test webhook settings

	Sends a test notification to the webhook agent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsWebhookTestPostRequest
	*/
	SettingsNotificationsWebhookTestPost(ctx context.Context) SettingsAPISettingsNotificationsWebhookTestPostRequest

	// SettingsNotificationsWebhookTestPostExecute executes the request
	SettingsNotificationsWebhookTestPostExecute(r SettingsAPISettingsNotificationsWebhookTestPostRequest) (*http.Response, error)

	/*
	SettingsNotificationsWebpushGet Get Web Push notification settings

	Returns current Web Push notification settings in a JSON object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsWebpushGetRequest
	*/
	SettingsNotificationsWebpushGet(ctx context.Context) SettingsAPISettingsNotificationsWebpushGetRequest

	// SettingsNotificationsWebpushGetExecute executes the request
	//  @return WebPushSettings
	SettingsNotificationsWebpushGetExecute(r SettingsAPISettingsNotificationsWebpushGetRequest) (*WebPushSettings, *http.Response, error)

	/*
	SettingsNotificationsWebpushPost Update Web Push notification settings

	Updates Web Push notification settings with the provided values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsWebpushPostRequest
	*/
	SettingsNotificationsWebpushPost(ctx context.Context) SettingsAPISettingsNotificationsWebpushPostRequest

	// SettingsNotificationsWebpushPostExecute executes the request
	//  @return WebPushSettings
	SettingsNotificationsWebpushPostExecute(r SettingsAPISettingsNotificationsWebpushPostRequest) (*WebPushSettings, *http.Response, error)

	/*
	SettingsNotificationsWebpushTestPost Test Web Push settings

	Sends a test notification to the Web Push agent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsNotificationsWebpushTestPostRequest
	*/
	SettingsNotificationsWebpushTestPost(ctx context.Context) SettingsAPISettingsNotificationsWebpushTestPostRequest

	// SettingsNotificationsWebpushTestPostExecute executes the request
	SettingsNotificationsWebpushTestPostExecute(r SettingsAPISettingsNotificationsWebpushTestPostRequest) (*http.Response, error)

	/*
	SettingsPlexDevicesServersGet Gets the user's available Plex servers

	Returns a list of available Plex servers and their connectivity state

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsPlexDevicesServersGetRequest
	*/
	SettingsPlexDevicesServersGet(ctx context.Context) SettingsAPISettingsPlexDevicesServersGetRequest

	// SettingsPlexDevicesServersGetExecute executes the request
	//  @return []PlexDevice
	SettingsPlexDevicesServersGetExecute(r SettingsAPISettingsPlexDevicesServersGetRequest) ([]PlexDevice, *http.Response, error)

	/*
	SettingsPlexGet Get Plex settings

	Retrieves current Plex settings.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsPlexGetRequest
	*/
	SettingsPlexGet(ctx context.Context) SettingsAPISettingsPlexGetRequest

	// SettingsPlexGetExecute executes the request
	//  @return PlexSettings
	SettingsPlexGetExecute(r SettingsAPISettingsPlexGetRequest) (*PlexSettings, *http.Response, error)

	/*
	SettingsPlexLibraryGet Get Plex libraries

	Returns a list of Plex libraries in a JSON array.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsPlexLibraryGetRequest
	*/
	SettingsPlexLibraryGet(ctx context.Context) SettingsAPISettingsPlexLibraryGetRequest

	// SettingsPlexLibraryGetExecute executes the request
	//  @return []PlexLibrary
	SettingsPlexLibraryGetExecute(r SettingsAPISettingsPlexLibraryGetRequest) ([]PlexLibrary, *http.Response, error)

	/*
	SettingsPlexPost Update Plex settings

	Updates Plex settings with the provided values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsPlexPostRequest
	*/
	SettingsPlexPost(ctx context.Context) SettingsAPISettingsPlexPostRequest

	// SettingsPlexPostExecute executes the request
	//  @return PlexSettings
	SettingsPlexPostExecute(r SettingsAPISettingsPlexPostRequest) (*PlexSettings, *http.Response, error)

	/*
	SettingsPlexSyncGet Get status of full Plex library scan

	Returns scan progress in a JSON array.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsPlexSyncGetRequest
	*/
	SettingsPlexSyncGet(ctx context.Context) SettingsAPISettingsPlexSyncGetRequest

	// SettingsPlexSyncGetExecute executes the request
	//  @return SettingsPlexSyncGet200Response
	SettingsPlexSyncGetExecute(r SettingsAPISettingsPlexSyncGetRequest) (*SettingsPlexSyncGet200Response, *http.Response, error)

	/*
	SettingsPlexSyncPost Start full Plex library scan

	Runs a full Plex library scan and returns the progress in a JSON array.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsPlexSyncPostRequest
	*/
	SettingsPlexSyncPost(ctx context.Context) SettingsAPISettingsPlexSyncPostRequest

	// SettingsPlexSyncPostExecute executes the request
	//  @return SettingsPlexSyncGet200Response
	SettingsPlexSyncPostExecute(r SettingsAPISettingsPlexSyncPostRequest) (*SettingsPlexSyncGet200Response, *http.Response, error)

	/*
	SettingsPlexUsersGet Get Plex users

	Returns a list of Plex users in a JSON array.

Requires the `MANAGE_USERS` permission.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsPlexUsersGetRequest
	*/
	SettingsPlexUsersGet(ctx context.Context) SettingsAPISettingsPlexUsersGetRequest

	// SettingsPlexUsersGetExecute executes the request
	//  @return []SettingsPlexUsersGet200ResponseInner
	SettingsPlexUsersGetExecute(r SettingsAPISettingsPlexUsersGetRequest) ([]SettingsPlexUsersGet200ResponseInner, *http.Response, error)

	/*
	SettingsPublicGet Get public settings

	Returns settings that are not protected or sensitive. Mainly used to determine if the application has been configured for the first time.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsPublicGetRequest
	*/
	SettingsPublicGet(ctx context.Context) SettingsAPISettingsPublicGetRequest

	// SettingsPublicGetExecute executes the request
	//  @return PublicSettings
	SettingsPublicGetExecute(r SettingsAPISettingsPublicGetRequest) (*PublicSettings, *http.Response, error)

	/*
	SettingsRadarrGet Get Radarr settings

	Returns all Radarr settings in a JSON array.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsRadarrGetRequest
	*/
	SettingsRadarrGet(ctx context.Context) SettingsAPISettingsRadarrGetRequest

	// SettingsRadarrGetExecute executes the request
	//  @return []RadarrSettings
	SettingsRadarrGetExecute(r SettingsAPISettingsRadarrGetRequest) ([]RadarrSettings, *http.Response, error)

	/*
	SettingsRadarrPost Create Radarr instance

	Creates a new Radarr instance from the request body.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsRadarrPostRequest
	*/
	SettingsRadarrPost(ctx context.Context) SettingsAPISettingsRadarrPostRequest

	// SettingsRadarrPostExecute executes the request
	//  @return RadarrSettings
	SettingsRadarrPostExecute(r SettingsAPISettingsRadarrPostRequest) (*RadarrSettings, *http.Response, error)

	/*
	SettingsRadarrRadarrIdDelete Delete Radarr instance

	Deletes an existing Radarr instance based on the radarrId parameter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param radarrId Radarr instance ID
	@return SettingsAPISettingsRadarrRadarrIdDeleteRequest
	*/
	SettingsRadarrRadarrIdDelete(ctx context.Context, radarrId int32) SettingsAPISettingsRadarrRadarrIdDeleteRequest

	// SettingsRadarrRadarrIdDeleteExecute executes the request
	//  @return RadarrSettings
	SettingsRadarrRadarrIdDeleteExecute(r SettingsAPISettingsRadarrRadarrIdDeleteRequest) (*RadarrSettings, *http.Response, error)

	/*
	SettingsRadarrRadarrIdProfilesGet Get available Radarr profiles

	Returns a list of profiles available on the Radarr server instance in a JSON array.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param radarrId Radarr instance ID
	@return SettingsAPISettingsRadarrRadarrIdProfilesGetRequest
	*/
	SettingsRadarrRadarrIdProfilesGet(ctx context.Context, radarrId int32) SettingsAPISettingsRadarrRadarrIdProfilesGetRequest

	// SettingsRadarrRadarrIdProfilesGetExecute executes the request
	//  @return []ServiceProfile
	SettingsRadarrRadarrIdProfilesGetExecute(r SettingsAPISettingsRadarrRadarrIdProfilesGetRequest) ([]ServiceProfile, *http.Response, error)

	/*
	SettingsRadarrRadarrIdPut Update Radarr instance

	Updates an existing Radarr instance with the provided values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param radarrId Radarr instance ID
	@return SettingsAPISettingsRadarrRadarrIdPutRequest
	*/
	SettingsRadarrRadarrIdPut(ctx context.Context, radarrId int32) SettingsAPISettingsRadarrRadarrIdPutRequest

	// SettingsRadarrRadarrIdPutExecute executes the request
	//  @return RadarrSettings
	SettingsRadarrRadarrIdPutExecute(r SettingsAPISettingsRadarrRadarrIdPutRequest) (*RadarrSettings, *http.Response, error)

	/*
	SettingsRadarrTestPost Test Radarr configuration

	Tests if the Radarr configuration is valid. Returns profiles and root folders on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsRadarrTestPostRequest
	*/
	SettingsRadarrTestPost(ctx context.Context) SettingsAPISettingsRadarrTestPostRequest

	// SettingsRadarrTestPostExecute executes the request
	//  @return SettingsRadarrTestPost200Response
	SettingsRadarrTestPostExecute(r SettingsAPISettingsRadarrTestPostRequest) (*SettingsRadarrTestPost200Response, *http.Response, error)

	/*
	SettingsSonarrGet Get Sonarr settings

	Returns all Sonarr settings in a JSON array.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsSonarrGetRequest
	*/
	SettingsSonarrGet(ctx context.Context) SettingsAPISettingsSonarrGetRequest

	// SettingsSonarrGetExecute executes the request
	//  @return []SonarrSettings
	SettingsSonarrGetExecute(r SettingsAPISettingsSonarrGetRequest) ([]SonarrSettings, *http.Response, error)

	/*
	SettingsSonarrPost Create Sonarr instance

	Creates a new Sonarr instance from the request body.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsSonarrPostRequest
	*/
	SettingsSonarrPost(ctx context.Context) SettingsAPISettingsSonarrPostRequest

	// SettingsSonarrPostExecute executes the request
	//  @return SonarrSettings
	SettingsSonarrPostExecute(r SettingsAPISettingsSonarrPostRequest) (*SonarrSettings, *http.Response, error)

	/*
	SettingsSonarrSonarrIdDelete Delete Sonarr instance

	Deletes an existing Sonarr instance based on the sonarrId parameter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sonarrId Sonarr instance ID
	@return SettingsAPISettingsSonarrSonarrIdDeleteRequest
	*/
	SettingsSonarrSonarrIdDelete(ctx context.Context, sonarrId int32) SettingsAPISettingsSonarrSonarrIdDeleteRequest

	// SettingsSonarrSonarrIdDeleteExecute executes the request
	//  @return SonarrSettings
	SettingsSonarrSonarrIdDeleteExecute(r SettingsAPISettingsSonarrSonarrIdDeleteRequest) (*SonarrSettings, *http.Response, error)

	/*
	SettingsSonarrSonarrIdPut Update Sonarr instance

	Updates an existing Sonarr instance with the provided values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sonarrId Sonarr instance ID
	@return SettingsAPISettingsSonarrSonarrIdPutRequest
	*/
	SettingsSonarrSonarrIdPut(ctx context.Context, sonarrId int32) SettingsAPISettingsSonarrSonarrIdPutRequest

	// SettingsSonarrSonarrIdPutExecute executes the request
	//  @return SonarrSettings
	SettingsSonarrSonarrIdPutExecute(r SettingsAPISettingsSonarrSonarrIdPutRequest) (*SonarrSettings, *http.Response, error)

	/*
	SettingsSonarrTestPost Test Sonarr configuration

	Tests if the Sonarr configuration is valid. Returns profiles and root folders on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsSonarrTestPostRequest
	*/
	SettingsSonarrTestPost(ctx context.Context) SettingsAPISettingsSonarrTestPostRequest

	// SettingsSonarrTestPostExecute executes the request
	//  @return SettingsRadarrTestPost200Response
	SettingsSonarrTestPostExecute(r SettingsAPISettingsSonarrTestPostRequest) (*SettingsRadarrTestPost200Response, *http.Response, error)

	/*
	SettingsTautulliGet Get Tautulli settings

	Retrieves current Tautulli settings.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsTautulliGetRequest
	*/
	SettingsTautulliGet(ctx context.Context) SettingsAPISettingsTautulliGetRequest

	// SettingsTautulliGetExecute executes the request
	//  @return TautulliSettings
	SettingsTautulliGetExecute(r SettingsAPISettingsTautulliGetRequest) (*TautulliSettings, *http.Response, error)

	/*
	SettingsTautulliPost Update Tautulli settings

	Updates Tautulli settings with the provided values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SettingsAPISettingsTautulliPostRequest
	*/
	SettingsTautulliPost(ctx context.Context) SettingsAPISettingsTautulliPostRequest

	// SettingsTautulliPostExecute executes the request
	//  @return TautulliSettings
	SettingsTautulliPostExecute(r SettingsAPISettingsTautulliPostRequest) (*TautulliSettings, *http.Response, error)
}

// SettingsAPIService SettingsAPI service
type SettingsAPIService service

type SettingsAPISettingsAboutGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsAboutGetRequest) Execute() (*SettingsAboutGet200Response, *http.Response, error) {
	return r.ApiService.SettingsAboutGetExecute(r)
}

/*
SettingsAboutGet Get server stats

Returns current server stats in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsAboutGetRequest
*/
func (a *SettingsAPIService) SettingsAboutGet(ctx context.Context) SettingsAPISettingsAboutGetRequest {
	return SettingsAPISettingsAboutGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SettingsAboutGet200Response
func (a *SettingsAPIService) SettingsAboutGetExecute(r SettingsAPISettingsAboutGetRequest) (*SettingsAboutGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SettingsAboutGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsAboutGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/about"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsCacheCacheIdFlushPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	cacheId string
}

func (r SettingsAPISettingsCacheCacheIdFlushPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SettingsCacheCacheIdFlushPostExecute(r)
}

/*
SettingsCacheCacheIdFlushPost Flush a specific cache

Flushes all data from the cache ID provided

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cacheId
 @return SettingsAPISettingsCacheCacheIdFlushPostRequest
*/
func (a *SettingsAPIService) SettingsCacheCacheIdFlushPost(ctx context.Context, cacheId string) SettingsAPISettingsCacheCacheIdFlushPostRequest {
	return SettingsAPISettingsCacheCacheIdFlushPostRequest{
		ApiService: a,
		ctx: ctx,
		cacheId: cacheId,
	}
}

// Execute executes the request
func (a *SettingsAPIService) SettingsCacheCacheIdFlushPostExecute(r SettingsAPISettingsCacheCacheIdFlushPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsCacheCacheIdFlushPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/cache/{cacheId}/flush"
	localVarPath = strings.Replace(localVarPath, "{"+"cacheId"+"}", url.PathEscape(parameterValueToString(r.cacheId, "cacheId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SettingsAPISettingsCacheGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsCacheGetRequest) Execute() (*SettingsCacheGet200Response, *http.Response, error) {
	return r.ApiService.SettingsCacheGetExecute(r)
}

/*
SettingsCacheGet Get a list of active caches

Retrieves a list of all active caches and their current stats.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsCacheGetRequest
*/
func (a *SettingsAPIService) SettingsCacheGet(ctx context.Context) SettingsAPISettingsCacheGetRequest {
	return SettingsAPISettingsCacheGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SettingsCacheGet200Response
func (a *SettingsAPIService) SettingsCacheGetExecute(r SettingsAPISettingsCacheGetRequest) (*SettingsCacheGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SettingsCacheGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsCacheGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsDiscoverAddPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	settingsDiscoverAddPostRequest *SettingsDiscoverAddPostRequest
}

func (r SettingsAPISettingsDiscoverAddPostRequest) SettingsDiscoverAddPostRequest(settingsDiscoverAddPostRequest SettingsDiscoverAddPostRequest) SettingsAPISettingsDiscoverAddPostRequest {
	r.settingsDiscoverAddPostRequest = &settingsDiscoverAddPostRequest
	return r
}

func (r SettingsAPISettingsDiscoverAddPostRequest) Execute() (*DiscoverSlider, *http.Response, error) {
	return r.ApiService.SettingsDiscoverAddPostExecute(r)
}

/*
SettingsDiscoverAddPost Add a new slider

Add a single slider and return the newly created slider. Requires the `ADMIN` permission.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsDiscoverAddPostRequest
*/
func (a *SettingsAPIService) SettingsDiscoverAddPost(ctx context.Context) SettingsAPISettingsDiscoverAddPostRequest {
	return SettingsAPISettingsDiscoverAddPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DiscoverSlider
func (a *SettingsAPIService) SettingsDiscoverAddPostExecute(r SettingsAPISettingsDiscoverAddPostRequest) (*DiscoverSlider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscoverSlider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsDiscoverAddPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/discover/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.settingsDiscoverAddPostRequest == nil {
		return localVarReturnValue, nil, reportError("settingsDiscoverAddPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.settingsDiscoverAddPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsDiscoverGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsDiscoverGetRequest) Execute() ([]DiscoverSlider, *http.Response, error) {
	return r.ApiService.SettingsDiscoverGetExecute(r)
}

/*
SettingsDiscoverGet Get all discover sliders

Returns all discovery sliders. Built-in and custom made.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsDiscoverGetRequest
*/
func (a *SettingsAPIService) SettingsDiscoverGet(ctx context.Context) SettingsAPISettingsDiscoverGetRequest {
	return SettingsAPISettingsDiscoverGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DiscoverSlider
func (a *SettingsAPIService) SettingsDiscoverGetExecute(r SettingsAPISettingsDiscoverGetRequest) ([]DiscoverSlider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DiscoverSlider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsDiscoverGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/discover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsDiscoverPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	discoverSlider *[]DiscoverSlider
}

func (r SettingsAPISettingsDiscoverPostRequest) DiscoverSlider(discoverSlider []DiscoverSlider) SettingsAPISettingsDiscoverPostRequest {
	r.discoverSlider = &discoverSlider
	return r
}

func (r SettingsAPISettingsDiscoverPostRequest) Execute() ([]DiscoverSlider, *http.Response, error) {
	return r.ApiService.SettingsDiscoverPostExecute(r)
}

/*
SettingsDiscoverPost Batch update all sliders.

Batch update all sliders at once. Should also be used for creation. Will only update sliders provided
and will not delete any sliders not present in the request. If a slider is missing a required field,
it will be ignored. Requires the `ADMIN` permission.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsDiscoverPostRequest
*/
func (a *SettingsAPIService) SettingsDiscoverPost(ctx context.Context) SettingsAPISettingsDiscoverPostRequest {
	return SettingsAPISettingsDiscoverPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DiscoverSlider
func (a *SettingsAPIService) SettingsDiscoverPostExecute(r SettingsAPISettingsDiscoverPostRequest) ([]DiscoverSlider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DiscoverSlider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsDiscoverPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/discover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.discoverSlider == nil {
		return localVarReturnValue, nil, reportError("discoverSlider is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.discoverSlider
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsDiscoverResetGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsDiscoverResetGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.SettingsDiscoverResetGetExecute(r)
}

/*
SettingsDiscoverResetGet Reset all discover sliders

Resets all discovery sliders to the default values. Requires the `ADMIN` permission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsDiscoverResetGetRequest
*/
func (a *SettingsAPIService) SettingsDiscoverResetGet(ctx context.Context) SettingsAPISettingsDiscoverResetGetRequest {
	return SettingsAPISettingsDiscoverResetGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SettingsAPIService) SettingsDiscoverResetGetExecute(r SettingsAPISettingsDiscoverResetGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsDiscoverResetGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/discover/reset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SettingsAPISettingsDiscoverSliderIdDeleteRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	sliderId float32
}

func (r SettingsAPISettingsDiscoverSliderIdDeleteRequest) Execute() (*DiscoverSlider, *http.Response, error) {
	return r.ApiService.SettingsDiscoverSliderIdDeleteExecute(r)
}

/*
SettingsDiscoverSliderIdDelete Delete slider by ID

Deletes the slider with the provided sliderId. Requires the `ADMIN` permission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sliderId
 @return SettingsAPISettingsDiscoverSliderIdDeleteRequest
*/
func (a *SettingsAPIService) SettingsDiscoverSliderIdDelete(ctx context.Context, sliderId float32) SettingsAPISettingsDiscoverSliderIdDeleteRequest {
	return SettingsAPISettingsDiscoverSliderIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		sliderId: sliderId,
	}
}

// Execute executes the request
//  @return DiscoverSlider
func (a *SettingsAPIService) SettingsDiscoverSliderIdDeleteExecute(r SettingsAPISettingsDiscoverSliderIdDeleteRequest) (*DiscoverSlider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscoverSlider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsDiscoverSliderIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/discover/{sliderId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sliderId"+"}", url.PathEscape(parameterValueToString(r.sliderId, "sliderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsDiscoverSliderIdPutRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	settingsDiscoverSliderIdPutRequest *SettingsDiscoverSliderIdPutRequest
}

func (r SettingsAPISettingsDiscoverSliderIdPutRequest) SettingsDiscoverSliderIdPutRequest(settingsDiscoverSliderIdPutRequest SettingsDiscoverSliderIdPutRequest) SettingsAPISettingsDiscoverSliderIdPutRequest {
	r.settingsDiscoverSliderIdPutRequest = &settingsDiscoverSliderIdPutRequest
	return r
}

func (r SettingsAPISettingsDiscoverSliderIdPutRequest) Execute() (*DiscoverSlider, *http.Response, error) {
	return r.ApiService.SettingsDiscoverSliderIdPutExecute(r)
}

/*
SettingsDiscoverSliderIdPut Update a single slider

Updates a single slider and return the newly updated slider. Requires the `ADMIN` permission.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsDiscoverSliderIdPutRequest
*/
func (a *SettingsAPIService) SettingsDiscoverSliderIdPut(ctx context.Context) SettingsAPISettingsDiscoverSliderIdPutRequest {
	return SettingsAPISettingsDiscoverSliderIdPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DiscoverSlider
func (a *SettingsAPIService) SettingsDiscoverSliderIdPutExecute(r SettingsAPISettingsDiscoverSliderIdPutRequest) (*DiscoverSlider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscoverSlider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsDiscoverSliderIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/discover/{sliderId}"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.settingsDiscoverSliderIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("settingsDiscoverSliderIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.settingsDiscoverSliderIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsInitializePostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsInitializePostRequest) Execute() (*PublicSettings, *http.Response, error) {
	return r.ApiService.SettingsInitializePostExecute(r)
}

/*
SettingsInitializePost Initialize application

Sets the app as initialized, allowing the user to navigate to pages other than the setup page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsInitializePostRequest
*/
func (a *SettingsAPIService) SettingsInitializePost(ctx context.Context) SettingsAPISettingsInitializePostRequest {
	return SettingsAPISettingsInitializePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PublicSettings
func (a *SettingsAPIService) SettingsInitializePostExecute(r SettingsAPISettingsInitializePostRequest) (*PublicSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsInitializePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/initialize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsJobsGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsJobsGetRequest) Execute() ([]Job, *http.Response, error) {
	return r.ApiService.SettingsJobsGetExecute(r)
}

/*
SettingsJobsGet Get scheduled jobs

Returns list of all scheduled jobs and details about their next execution time in a JSON array.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsJobsGetRequest
*/
func (a *SettingsAPIService) SettingsJobsGet(ctx context.Context) SettingsAPISettingsJobsGetRequest {
	return SettingsAPISettingsJobsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Job
func (a *SettingsAPIService) SettingsJobsGetExecute(r SettingsAPISettingsJobsGetRequest) ([]Job, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Job
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsJobsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsJobsJobIdCancelPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	jobId string
}

func (r SettingsAPISettingsJobsJobIdCancelPostRequest) Execute() (*Job, *http.Response, error) {
	return r.ApiService.SettingsJobsJobIdCancelPostExecute(r)
}

/*
SettingsJobsJobIdCancelPost Cancel a specific job

Cancels a specific job. Will return the new job status in JSON format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId
 @return SettingsAPISettingsJobsJobIdCancelPostRequest
*/
func (a *SettingsAPIService) SettingsJobsJobIdCancelPost(ctx context.Context, jobId string) SettingsAPISettingsJobsJobIdCancelPostRequest {
	return SettingsAPISettingsJobsJobIdCancelPostRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return Job
func (a *SettingsAPIService) SettingsJobsJobIdCancelPostExecute(r SettingsAPISettingsJobsJobIdCancelPostRequest) (*Job, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Job
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsJobsJobIdCancelPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/jobs/{jobId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsJobsJobIdRunPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	jobId string
}

func (r SettingsAPISettingsJobsJobIdRunPostRequest) Execute() (*Job, *http.Response, error) {
	return r.ApiService.SettingsJobsJobIdRunPostExecute(r)
}

/*
SettingsJobsJobIdRunPost Invoke a specific job

Invokes a specific job to run. Will return the new job status in JSON format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId
 @return SettingsAPISettingsJobsJobIdRunPostRequest
*/
func (a *SettingsAPIService) SettingsJobsJobIdRunPost(ctx context.Context, jobId string) SettingsAPISettingsJobsJobIdRunPostRequest {
	return SettingsAPISettingsJobsJobIdRunPostRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return Job
func (a *SettingsAPIService) SettingsJobsJobIdRunPostExecute(r SettingsAPISettingsJobsJobIdRunPostRequest) (*Job, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Job
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsJobsJobIdRunPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/jobs/{jobId}/run"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsJobsJobIdSchedulePostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	jobId string
	settingsJobsJobIdSchedulePostRequest *SettingsJobsJobIdSchedulePostRequest
}

func (r SettingsAPISettingsJobsJobIdSchedulePostRequest) SettingsJobsJobIdSchedulePostRequest(settingsJobsJobIdSchedulePostRequest SettingsJobsJobIdSchedulePostRequest) SettingsAPISettingsJobsJobIdSchedulePostRequest {
	r.settingsJobsJobIdSchedulePostRequest = &settingsJobsJobIdSchedulePostRequest
	return r
}

func (r SettingsAPISettingsJobsJobIdSchedulePostRequest) Execute() (*Job, *http.Response, error) {
	return r.ApiService.SettingsJobsJobIdSchedulePostExecute(r)
}

/*
SettingsJobsJobIdSchedulePost Modify job schedule

Re-registers the job with the schedule specified. Will return the job in JSON format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId
 @return SettingsAPISettingsJobsJobIdSchedulePostRequest
*/
func (a *SettingsAPIService) SettingsJobsJobIdSchedulePost(ctx context.Context, jobId string) SettingsAPISettingsJobsJobIdSchedulePostRequest {
	return SettingsAPISettingsJobsJobIdSchedulePostRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return Job
func (a *SettingsAPIService) SettingsJobsJobIdSchedulePostExecute(r SettingsAPISettingsJobsJobIdSchedulePostRequest) (*Job, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Job
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsJobsJobIdSchedulePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/jobs/{jobId}/schedule"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.settingsJobsJobIdSchedulePostRequest == nil {
		return localVarReturnValue, nil, reportError("settingsJobsJobIdSchedulePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.settingsJobsJobIdSchedulePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsLogsGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	take *float32
	skip *float32
	filter *string
	search *string
}

func (r SettingsAPISettingsLogsGetRequest) Take(take float32) SettingsAPISettingsLogsGetRequest {
	r.take = &take
	return r
}

func (r SettingsAPISettingsLogsGetRequest) Skip(skip float32) SettingsAPISettingsLogsGetRequest {
	r.skip = &skip
	return r
}

func (r SettingsAPISettingsLogsGetRequest) Filter(filter string) SettingsAPISettingsLogsGetRequest {
	r.filter = &filter
	return r
}

func (r SettingsAPISettingsLogsGetRequest) Search(search string) SettingsAPISettingsLogsGetRequest {
	r.search = &search
	return r
}

func (r SettingsAPISettingsLogsGetRequest) Execute() ([]SettingsLogsGet200ResponseInner, *http.Response, error) {
	return r.ApiService.SettingsLogsGetExecute(r)
}

/*
SettingsLogsGet Returns logs

Returns list of all log items and details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsLogsGetRequest
*/
func (a *SettingsAPIService) SettingsLogsGet(ctx context.Context) SettingsAPISettingsLogsGetRequest {
	return SettingsAPISettingsLogsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SettingsLogsGet200ResponseInner
func (a *SettingsAPIService) SettingsLogsGetExecute(r SettingsAPISettingsLogsGetRequest) ([]SettingsLogsGet200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SettingsLogsGet200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsLogsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.take != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "take", r.take, "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = "debug"
		r.filter = &defaultValue
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsMainGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsMainGetRequest) Execute() (*MainSettings, *http.Response, error) {
	return r.ApiService.SettingsMainGetExecute(r)
}

/*
SettingsMainGet Get main settings

Retrieves all main settings in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsMainGetRequest
*/
func (a *SettingsAPIService) SettingsMainGet(ctx context.Context) SettingsAPISettingsMainGetRequest {
	return SettingsAPISettingsMainGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MainSettings
func (a *SettingsAPIService) SettingsMainGetExecute(r SettingsAPISettingsMainGetRequest) (*MainSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MainSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsMainGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/main"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsMainPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	mainSettings *MainSettings
}

func (r SettingsAPISettingsMainPostRequest) MainSettings(mainSettings MainSettings) SettingsAPISettingsMainPostRequest {
	r.mainSettings = &mainSettings
	return r
}

func (r SettingsAPISettingsMainPostRequest) Execute() (*MainSettings, *http.Response, error) {
	return r.ApiService.SettingsMainPostExecute(r)
}

/*
SettingsMainPost Update main settings

Updates main settings with the provided values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsMainPostRequest
*/
func (a *SettingsAPIService) SettingsMainPost(ctx context.Context) SettingsAPISettingsMainPostRequest {
	return SettingsAPISettingsMainPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MainSettings
func (a *SettingsAPIService) SettingsMainPostExecute(r SettingsAPISettingsMainPostRequest) (*MainSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MainSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsMainPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/main"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mainSettings == nil {
		return localVarReturnValue, nil, reportError("mainSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mainSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsMainRegeneratePostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsMainRegeneratePostRequest) Execute() (*MainSettings, *http.Response, error) {
	return r.ApiService.SettingsMainRegeneratePostExecute(r)
}

/*
SettingsMainRegeneratePost Get main settings with newly-generated API key

Returns main settings in a JSON object, using the new API key.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsMainRegeneratePostRequest
*/
func (a *SettingsAPIService) SettingsMainRegeneratePost(ctx context.Context) SettingsAPISettingsMainRegeneratePostRequest {
	return SettingsAPISettingsMainRegeneratePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MainSettings
func (a *SettingsAPIService) SettingsMainRegeneratePostExecute(r SettingsAPISettingsMainRegeneratePostRequest) (*MainSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MainSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsMainRegeneratePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/main/regenerate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsDiscordGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsNotificationsDiscordGetRequest) Execute() (*DiscordSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsDiscordGetExecute(r)
}

/*
SettingsNotificationsDiscordGet Get Discord notification settings

Returns current Discord notification settings in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsDiscordGetRequest
*/
func (a *SettingsAPIService) SettingsNotificationsDiscordGet(ctx context.Context) SettingsAPISettingsNotificationsDiscordGetRequest {
	return SettingsAPISettingsNotificationsDiscordGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DiscordSettings
func (a *SettingsAPIService) SettingsNotificationsDiscordGetExecute(r SettingsAPISettingsNotificationsDiscordGetRequest) (*DiscordSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscordSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsDiscordGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/discord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsDiscordPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	discordSettings *DiscordSettings
}

func (r SettingsAPISettingsNotificationsDiscordPostRequest) DiscordSettings(discordSettings DiscordSettings) SettingsAPISettingsNotificationsDiscordPostRequest {
	r.discordSettings = &discordSettings
	return r
}

func (r SettingsAPISettingsNotificationsDiscordPostRequest) Execute() (*DiscordSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsDiscordPostExecute(r)
}

/*
SettingsNotificationsDiscordPost Update Discord notification settings

Updates Discord notification settings with the provided values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsDiscordPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsDiscordPost(ctx context.Context) SettingsAPISettingsNotificationsDiscordPostRequest {
	return SettingsAPISettingsNotificationsDiscordPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DiscordSettings
func (a *SettingsAPIService) SettingsNotificationsDiscordPostExecute(r SettingsAPISettingsNotificationsDiscordPostRequest) (*DiscordSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiscordSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsDiscordPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/discord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.discordSettings == nil {
		return localVarReturnValue, nil, reportError("discordSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.discordSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsDiscordTestPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	discordSettings *DiscordSettings
}

func (r SettingsAPISettingsNotificationsDiscordTestPostRequest) DiscordSettings(discordSettings DiscordSettings) SettingsAPISettingsNotificationsDiscordTestPostRequest {
	r.discordSettings = &discordSettings
	return r
}

func (r SettingsAPISettingsNotificationsDiscordTestPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SettingsNotificationsDiscordTestPostExecute(r)
}

/*
SettingsNotificationsDiscordTestPost Test Discord settings

Sends a test notification to the Discord agent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsDiscordTestPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsDiscordTestPost(ctx context.Context) SettingsAPISettingsNotificationsDiscordTestPostRequest {
	return SettingsAPISettingsNotificationsDiscordTestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SettingsAPIService) SettingsNotificationsDiscordTestPostExecute(r SettingsAPISettingsNotificationsDiscordTestPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsDiscordTestPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/discord/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.discordSettings == nil {
		return nil, reportError("discordSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.discordSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsEmailGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsNotificationsEmailGetRequest) Execute() (*NotificationEmailSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsEmailGetExecute(r)
}

/*
SettingsNotificationsEmailGet Get email notification settings

Returns current email notification settings in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsEmailGetRequest
*/
func (a *SettingsAPIService) SettingsNotificationsEmailGet(ctx context.Context) SettingsAPISettingsNotificationsEmailGetRequest {
	return SettingsAPISettingsNotificationsEmailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationEmailSettings
func (a *SettingsAPIService) SettingsNotificationsEmailGetExecute(r SettingsAPISettingsNotificationsEmailGetRequest) (*NotificationEmailSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationEmailSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsEmailGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsEmailPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	notificationEmailSettings *NotificationEmailSettings
}

func (r SettingsAPISettingsNotificationsEmailPostRequest) NotificationEmailSettings(notificationEmailSettings NotificationEmailSettings) SettingsAPISettingsNotificationsEmailPostRequest {
	r.notificationEmailSettings = &notificationEmailSettings
	return r
}

func (r SettingsAPISettingsNotificationsEmailPostRequest) Execute() (*NotificationEmailSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsEmailPostExecute(r)
}

/*
SettingsNotificationsEmailPost Update email notification settings

Updates email notification settings with provided values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsEmailPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsEmailPost(ctx context.Context) SettingsAPISettingsNotificationsEmailPostRequest {
	return SettingsAPISettingsNotificationsEmailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationEmailSettings
func (a *SettingsAPIService) SettingsNotificationsEmailPostExecute(r SettingsAPISettingsNotificationsEmailPostRequest) (*NotificationEmailSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationEmailSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsEmailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.notificationEmailSettings == nil {
		return localVarReturnValue, nil, reportError("notificationEmailSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationEmailSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsEmailTestPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	notificationEmailSettings *NotificationEmailSettings
}

func (r SettingsAPISettingsNotificationsEmailTestPostRequest) NotificationEmailSettings(notificationEmailSettings NotificationEmailSettings) SettingsAPISettingsNotificationsEmailTestPostRequest {
	r.notificationEmailSettings = &notificationEmailSettings
	return r
}

func (r SettingsAPISettingsNotificationsEmailTestPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SettingsNotificationsEmailTestPostExecute(r)
}

/*
SettingsNotificationsEmailTestPost Test email settings

Sends a test notification to the email agent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsEmailTestPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsEmailTestPost(ctx context.Context) SettingsAPISettingsNotificationsEmailTestPostRequest {
	return SettingsAPISettingsNotificationsEmailTestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SettingsAPIService) SettingsNotificationsEmailTestPostExecute(r SettingsAPISettingsNotificationsEmailTestPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsEmailTestPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/email/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.notificationEmailSettings == nil {
		return nil, reportError("notificationEmailSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationEmailSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsGotifyGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsNotificationsGotifyGetRequest) Execute() (*GotifySettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsGotifyGetExecute(r)
}

/*
SettingsNotificationsGotifyGet Get Gotify notification settings

Returns current Gotify notification settings in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsGotifyGetRequest
*/
func (a *SettingsAPIService) SettingsNotificationsGotifyGet(ctx context.Context) SettingsAPISettingsNotificationsGotifyGetRequest {
	return SettingsAPISettingsNotificationsGotifyGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GotifySettings
func (a *SettingsAPIService) SettingsNotificationsGotifyGetExecute(r SettingsAPISettingsNotificationsGotifyGetRequest) (*GotifySettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GotifySettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsGotifyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/gotify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsGotifyPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	gotifySettings *GotifySettings
}

func (r SettingsAPISettingsNotificationsGotifyPostRequest) GotifySettings(gotifySettings GotifySettings) SettingsAPISettingsNotificationsGotifyPostRequest {
	r.gotifySettings = &gotifySettings
	return r
}

func (r SettingsAPISettingsNotificationsGotifyPostRequest) Execute() (*GotifySettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsGotifyPostExecute(r)
}

/*
SettingsNotificationsGotifyPost Update Gotify notification settings

Update Gotify notification settings with the provided values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsGotifyPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsGotifyPost(ctx context.Context) SettingsAPISettingsNotificationsGotifyPostRequest {
	return SettingsAPISettingsNotificationsGotifyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GotifySettings
func (a *SettingsAPIService) SettingsNotificationsGotifyPostExecute(r SettingsAPISettingsNotificationsGotifyPostRequest) (*GotifySettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GotifySettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsGotifyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/gotify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gotifySettings == nil {
		return localVarReturnValue, nil, reportError("gotifySettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gotifySettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsGotifyTestPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	gotifySettings *GotifySettings
}

func (r SettingsAPISettingsNotificationsGotifyTestPostRequest) GotifySettings(gotifySettings GotifySettings) SettingsAPISettingsNotificationsGotifyTestPostRequest {
	r.gotifySettings = &gotifySettings
	return r
}

func (r SettingsAPISettingsNotificationsGotifyTestPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SettingsNotificationsGotifyTestPostExecute(r)
}

/*
SettingsNotificationsGotifyTestPost Test Gotify settings

Sends a test notification to the Gotify agent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsGotifyTestPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsGotifyTestPost(ctx context.Context) SettingsAPISettingsNotificationsGotifyTestPostRequest {
	return SettingsAPISettingsNotificationsGotifyTestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SettingsAPIService) SettingsNotificationsGotifyTestPostExecute(r SettingsAPISettingsNotificationsGotifyTestPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsGotifyTestPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/gotify/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gotifySettings == nil {
		return nil, reportError("gotifySettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gotifySettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsLunaseaGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsNotificationsLunaseaGetRequest) Execute() (*LunaSeaSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsLunaseaGetExecute(r)
}

/*
SettingsNotificationsLunaseaGet Get LunaSea notification settings

Returns current LunaSea notification settings in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsLunaseaGetRequest
*/
func (a *SettingsAPIService) SettingsNotificationsLunaseaGet(ctx context.Context) SettingsAPISettingsNotificationsLunaseaGetRequest {
	return SettingsAPISettingsNotificationsLunaseaGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LunaSeaSettings
func (a *SettingsAPIService) SettingsNotificationsLunaseaGetExecute(r SettingsAPISettingsNotificationsLunaseaGetRequest) (*LunaSeaSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LunaSeaSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsLunaseaGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/lunasea"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsLunaseaPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	lunaSeaSettings *LunaSeaSettings
}

func (r SettingsAPISettingsNotificationsLunaseaPostRequest) LunaSeaSettings(lunaSeaSettings LunaSeaSettings) SettingsAPISettingsNotificationsLunaseaPostRequest {
	r.lunaSeaSettings = &lunaSeaSettings
	return r
}

func (r SettingsAPISettingsNotificationsLunaseaPostRequest) Execute() (*LunaSeaSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsLunaseaPostExecute(r)
}

/*
SettingsNotificationsLunaseaPost Update LunaSea notification settings

Updates LunaSea notification settings with the provided values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsLunaseaPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsLunaseaPost(ctx context.Context) SettingsAPISettingsNotificationsLunaseaPostRequest {
	return SettingsAPISettingsNotificationsLunaseaPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LunaSeaSettings
func (a *SettingsAPIService) SettingsNotificationsLunaseaPostExecute(r SettingsAPISettingsNotificationsLunaseaPostRequest) (*LunaSeaSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LunaSeaSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsLunaseaPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/lunasea"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lunaSeaSettings == nil {
		return localVarReturnValue, nil, reportError("lunaSeaSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.lunaSeaSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsLunaseaTestPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	lunaSeaSettings *LunaSeaSettings
}

func (r SettingsAPISettingsNotificationsLunaseaTestPostRequest) LunaSeaSettings(lunaSeaSettings LunaSeaSettings) SettingsAPISettingsNotificationsLunaseaTestPostRequest {
	r.lunaSeaSettings = &lunaSeaSettings
	return r
}

func (r SettingsAPISettingsNotificationsLunaseaTestPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SettingsNotificationsLunaseaTestPostExecute(r)
}

/*
SettingsNotificationsLunaseaTestPost Test LunaSea settings

Sends a test notification to the LunaSea agent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsLunaseaTestPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsLunaseaTestPost(ctx context.Context) SettingsAPISettingsNotificationsLunaseaTestPostRequest {
	return SettingsAPISettingsNotificationsLunaseaTestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SettingsAPIService) SettingsNotificationsLunaseaTestPostExecute(r SettingsAPISettingsNotificationsLunaseaTestPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsLunaseaTestPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/lunasea/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lunaSeaSettings == nil {
		return nil, reportError("lunaSeaSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.lunaSeaSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsPushbulletGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsNotificationsPushbulletGetRequest) Execute() (*PushbulletSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsPushbulletGetExecute(r)
}

/*
SettingsNotificationsPushbulletGet Get Pushbullet notification settings

Returns current Pushbullet notification settings in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsPushbulletGetRequest
*/
func (a *SettingsAPIService) SettingsNotificationsPushbulletGet(ctx context.Context) SettingsAPISettingsNotificationsPushbulletGetRequest {
	return SettingsAPISettingsNotificationsPushbulletGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PushbulletSettings
func (a *SettingsAPIService) SettingsNotificationsPushbulletGetExecute(r SettingsAPISettingsNotificationsPushbulletGetRequest) (*PushbulletSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PushbulletSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsPushbulletGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/pushbullet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsPushbulletPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	pushbulletSettings *PushbulletSettings
}

func (r SettingsAPISettingsNotificationsPushbulletPostRequest) PushbulletSettings(pushbulletSettings PushbulletSettings) SettingsAPISettingsNotificationsPushbulletPostRequest {
	r.pushbulletSettings = &pushbulletSettings
	return r
}

func (r SettingsAPISettingsNotificationsPushbulletPostRequest) Execute() (*PushbulletSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsPushbulletPostExecute(r)
}

/*
SettingsNotificationsPushbulletPost Update Pushbullet notification settings

Update Pushbullet notification settings with the provided values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsPushbulletPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsPushbulletPost(ctx context.Context) SettingsAPISettingsNotificationsPushbulletPostRequest {
	return SettingsAPISettingsNotificationsPushbulletPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PushbulletSettings
func (a *SettingsAPIService) SettingsNotificationsPushbulletPostExecute(r SettingsAPISettingsNotificationsPushbulletPostRequest) (*PushbulletSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PushbulletSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsPushbulletPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/pushbullet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pushbulletSettings == nil {
		return localVarReturnValue, nil, reportError("pushbulletSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pushbulletSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsPushbulletTestPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	pushbulletSettings *PushbulletSettings
}

func (r SettingsAPISettingsNotificationsPushbulletTestPostRequest) PushbulletSettings(pushbulletSettings PushbulletSettings) SettingsAPISettingsNotificationsPushbulletTestPostRequest {
	r.pushbulletSettings = &pushbulletSettings
	return r
}

func (r SettingsAPISettingsNotificationsPushbulletTestPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SettingsNotificationsPushbulletTestPostExecute(r)
}

/*
SettingsNotificationsPushbulletTestPost Test Pushbullet settings

Sends a test notification to the Pushbullet agent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsPushbulletTestPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsPushbulletTestPost(ctx context.Context) SettingsAPISettingsNotificationsPushbulletTestPostRequest {
	return SettingsAPISettingsNotificationsPushbulletTestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SettingsAPIService) SettingsNotificationsPushbulletTestPostExecute(r SettingsAPISettingsNotificationsPushbulletTestPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsPushbulletTestPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/pushbullet/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pushbulletSettings == nil {
		return nil, reportError("pushbulletSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pushbulletSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsPushoverGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsNotificationsPushoverGetRequest) Execute() (*PushoverSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsPushoverGetExecute(r)
}

/*
SettingsNotificationsPushoverGet Get Pushover notification settings

Returns current Pushover notification settings in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsPushoverGetRequest
*/
func (a *SettingsAPIService) SettingsNotificationsPushoverGet(ctx context.Context) SettingsAPISettingsNotificationsPushoverGetRequest {
	return SettingsAPISettingsNotificationsPushoverGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PushoverSettings
func (a *SettingsAPIService) SettingsNotificationsPushoverGetExecute(r SettingsAPISettingsNotificationsPushoverGetRequest) (*PushoverSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PushoverSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsPushoverGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/pushover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsPushoverPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	pushoverSettings *PushoverSettings
}

func (r SettingsAPISettingsNotificationsPushoverPostRequest) PushoverSettings(pushoverSettings PushoverSettings) SettingsAPISettingsNotificationsPushoverPostRequest {
	r.pushoverSettings = &pushoverSettings
	return r
}

func (r SettingsAPISettingsNotificationsPushoverPostRequest) Execute() (*PushoverSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsPushoverPostExecute(r)
}

/*
SettingsNotificationsPushoverPost Update Pushover notification settings

Update Pushover notification settings with the provided values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsPushoverPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsPushoverPost(ctx context.Context) SettingsAPISettingsNotificationsPushoverPostRequest {
	return SettingsAPISettingsNotificationsPushoverPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PushoverSettings
func (a *SettingsAPIService) SettingsNotificationsPushoverPostExecute(r SettingsAPISettingsNotificationsPushoverPostRequest) (*PushoverSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PushoverSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsPushoverPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/pushover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pushoverSettings == nil {
		return localVarReturnValue, nil, reportError("pushoverSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pushoverSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsPushoverSoundsGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	token *string
}

func (r SettingsAPISettingsNotificationsPushoverSoundsGetRequest) Token(token string) SettingsAPISettingsNotificationsPushoverSoundsGetRequest {
	r.token = &token
	return r
}

func (r SettingsAPISettingsNotificationsPushoverSoundsGetRequest) Execute() ([]SettingsNotificationsPushoverSoundsGet200ResponseInner, *http.Response, error) {
	return r.ApiService.SettingsNotificationsPushoverSoundsGetExecute(r)
}

/*
SettingsNotificationsPushoverSoundsGet Get Pushover sounds

Returns valid Pushover sound options in a JSON array.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsPushoverSoundsGetRequest
*/
func (a *SettingsAPIService) SettingsNotificationsPushoverSoundsGet(ctx context.Context) SettingsAPISettingsNotificationsPushoverSoundsGetRequest {
	return SettingsAPISettingsNotificationsPushoverSoundsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SettingsNotificationsPushoverSoundsGet200ResponseInner
func (a *SettingsAPIService) SettingsNotificationsPushoverSoundsGetExecute(r SettingsAPISettingsNotificationsPushoverSoundsGetRequest) ([]SettingsNotificationsPushoverSoundsGet200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SettingsNotificationsPushoverSoundsGet200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsPushoverSoundsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/pushover/sounds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsPushoverTestPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	pushoverSettings *PushoverSettings
}

func (r SettingsAPISettingsNotificationsPushoverTestPostRequest) PushoverSettings(pushoverSettings PushoverSettings) SettingsAPISettingsNotificationsPushoverTestPostRequest {
	r.pushoverSettings = &pushoverSettings
	return r
}

func (r SettingsAPISettingsNotificationsPushoverTestPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SettingsNotificationsPushoverTestPostExecute(r)
}

/*
SettingsNotificationsPushoverTestPost Test Pushover settings

Sends a test notification to the Pushover agent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsPushoverTestPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsPushoverTestPost(ctx context.Context) SettingsAPISettingsNotificationsPushoverTestPostRequest {
	return SettingsAPISettingsNotificationsPushoverTestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SettingsAPIService) SettingsNotificationsPushoverTestPostExecute(r SettingsAPISettingsNotificationsPushoverTestPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsPushoverTestPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/pushover/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pushoverSettings == nil {
		return nil, reportError("pushoverSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pushoverSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsSlackGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsNotificationsSlackGetRequest) Execute() (*SlackSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsSlackGetExecute(r)
}

/*
SettingsNotificationsSlackGet Get Slack notification settings

Returns current Slack notification settings in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsSlackGetRequest
*/
func (a *SettingsAPIService) SettingsNotificationsSlackGet(ctx context.Context) SettingsAPISettingsNotificationsSlackGetRequest {
	return SettingsAPISettingsNotificationsSlackGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SlackSettings
func (a *SettingsAPIService) SettingsNotificationsSlackGetExecute(r SettingsAPISettingsNotificationsSlackGetRequest) (*SlackSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SlackSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsSlackGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/slack"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsSlackPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	slackSettings *SlackSettings
}

func (r SettingsAPISettingsNotificationsSlackPostRequest) SlackSettings(slackSettings SlackSettings) SettingsAPISettingsNotificationsSlackPostRequest {
	r.slackSettings = &slackSettings
	return r
}

func (r SettingsAPISettingsNotificationsSlackPostRequest) Execute() (*SlackSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsSlackPostExecute(r)
}

/*
SettingsNotificationsSlackPost Update Slack notification settings

Updates Slack notification settings with the provided values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsSlackPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsSlackPost(ctx context.Context) SettingsAPISettingsNotificationsSlackPostRequest {
	return SettingsAPISettingsNotificationsSlackPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SlackSettings
func (a *SettingsAPIService) SettingsNotificationsSlackPostExecute(r SettingsAPISettingsNotificationsSlackPostRequest) (*SlackSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SlackSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsSlackPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/slack"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.slackSettings == nil {
		return localVarReturnValue, nil, reportError("slackSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.slackSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsSlackTestPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	slackSettings *SlackSettings
}

func (r SettingsAPISettingsNotificationsSlackTestPostRequest) SlackSettings(slackSettings SlackSettings) SettingsAPISettingsNotificationsSlackTestPostRequest {
	r.slackSettings = &slackSettings
	return r
}

func (r SettingsAPISettingsNotificationsSlackTestPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SettingsNotificationsSlackTestPostExecute(r)
}

/*
SettingsNotificationsSlackTestPost Test Slack settings

Sends a test notification to the Slack agent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsSlackTestPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsSlackTestPost(ctx context.Context) SettingsAPISettingsNotificationsSlackTestPostRequest {
	return SettingsAPISettingsNotificationsSlackTestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SettingsAPIService) SettingsNotificationsSlackTestPostExecute(r SettingsAPISettingsNotificationsSlackTestPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsSlackTestPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/slack/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.slackSettings == nil {
		return nil, reportError("slackSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.slackSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsTelegramGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsNotificationsTelegramGetRequest) Execute() (*TelegramSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsTelegramGetExecute(r)
}

/*
SettingsNotificationsTelegramGet Get Telegram notification settings

Returns current Telegram notification settings in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsTelegramGetRequest
*/
func (a *SettingsAPIService) SettingsNotificationsTelegramGet(ctx context.Context) SettingsAPISettingsNotificationsTelegramGetRequest {
	return SettingsAPISettingsNotificationsTelegramGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TelegramSettings
func (a *SettingsAPIService) SettingsNotificationsTelegramGetExecute(r SettingsAPISettingsNotificationsTelegramGetRequest) (*TelegramSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TelegramSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsTelegramGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/telegram"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsTelegramPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	telegramSettings *TelegramSettings
}

func (r SettingsAPISettingsNotificationsTelegramPostRequest) TelegramSettings(telegramSettings TelegramSettings) SettingsAPISettingsNotificationsTelegramPostRequest {
	r.telegramSettings = &telegramSettings
	return r
}

func (r SettingsAPISettingsNotificationsTelegramPostRequest) Execute() (*TelegramSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsTelegramPostExecute(r)
}

/*
SettingsNotificationsTelegramPost Update Telegram notification settings

Update Telegram notification settings with the provided values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsTelegramPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsTelegramPost(ctx context.Context) SettingsAPISettingsNotificationsTelegramPostRequest {
	return SettingsAPISettingsNotificationsTelegramPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TelegramSettings
func (a *SettingsAPIService) SettingsNotificationsTelegramPostExecute(r SettingsAPISettingsNotificationsTelegramPostRequest) (*TelegramSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TelegramSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsTelegramPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/telegram"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.telegramSettings == nil {
		return localVarReturnValue, nil, reportError("telegramSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.telegramSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsTelegramTestPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	telegramSettings *TelegramSettings
}

func (r SettingsAPISettingsNotificationsTelegramTestPostRequest) TelegramSettings(telegramSettings TelegramSettings) SettingsAPISettingsNotificationsTelegramTestPostRequest {
	r.telegramSettings = &telegramSettings
	return r
}

func (r SettingsAPISettingsNotificationsTelegramTestPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SettingsNotificationsTelegramTestPostExecute(r)
}

/*
SettingsNotificationsTelegramTestPost Test Telegram settings

Sends a test notification to the Telegram agent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsTelegramTestPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsTelegramTestPost(ctx context.Context) SettingsAPISettingsNotificationsTelegramTestPostRequest {
	return SettingsAPISettingsNotificationsTelegramTestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SettingsAPIService) SettingsNotificationsTelegramTestPostExecute(r SettingsAPISettingsNotificationsTelegramTestPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsTelegramTestPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/telegram/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.telegramSettings == nil {
		return nil, reportError("telegramSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.telegramSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsWebhookGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsNotificationsWebhookGetRequest) Execute() (*WebhookSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsWebhookGetExecute(r)
}

/*
SettingsNotificationsWebhookGet Get webhook notification settings

Returns current webhook notification settings in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsWebhookGetRequest
*/
func (a *SettingsAPIService) SettingsNotificationsWebhookGet(ctx context.Context) SettingsAPISettingsNotificationsWebhookGetRequest {
	return SettingsAPISettingsNotificationsWebhookGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WebhookSettings
func (a *SettingsAPIService) SettingsNotificationsWebhookGetExecute(r SettingsAPISettingsNotificationsWebhookGetRequest) (*WebhookSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebhookSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsWebhookGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/webhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsWebhookPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	webhookSettings *WebhookSettings
}

func (r SettingsAPISettingsNotificationsWebhookPostRequest) WebhookSettings(webhookSettings WebhookSettings) SettingsAPISettingsNotificationsWebhookPostRequest {
	r.webhookSettings = &webhookSettings
	return r
}

func (r SettingsAPISettingsNotificationsWebhookPostRequest) Execute() (*WebhookSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsWebhookPostExecute(r)
}

/*
SettingsNotificationsWebhookPost Update webhook notification settings

Updates webhook notification settings with the provided values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsWebhookPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsWebhookPost(ctx context.Context) SettingsAPISettingsNotificationsWebhookPostRequest {
	return SettingsAPISettingsNotificationsWebhookPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WebhookSettings
func (a *SettingsAPIService) SettingsNotificationsWebhookPostExecute(r SettingsAPISettingsNotificationsWebhookPostRequest) (*WebhookSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebhookSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsWebhookPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/webhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.webhookSettings == nil {
		return localVarReturnValue, nil, reportError("webhookSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsWebhookTestPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	webhookSettings *WebhookSettings
}

func (r SettingsAPISettingsNotificationsWebhookTestPostRequest) WebhookSettings(webhookSettings WebhookSettings) SettingsAPISettingsNotificationsWebhookTestPostRequest {
	r.webhookSettings = &webhookSettings
	return r
}

func (r SettingsAPISettingsNotificationsWebhookTestPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SettingsNotificationsWebhookTestPostExecute(r)
}

/*
SettingsNotificationsWebhookTestPost Test webhook settings

Sends a test notification to the webhook agent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsWebhookTestPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsWebhookTestPost(ctx context.Context) SettingsAPISettingsNotificationsWebhookTestPostRequest {
	return SettingsAPISettingsNotificationsWebhookTestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SettingsAPIService) SettingsNotificationsWebhookTestPostExecute(r SettingsAPISettingsNotificationsWebhookTestPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsWebhookTestPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/webhook/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.webhookSettings == nil {
		return nil, reportError("webhookSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsWebpushGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsNotificationsWebpushGetRequest) Execute() (*WebPushSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsWebpushGetExecute(r)
}

/*
SettingsNotificationsWebpushGet Get Web Push notification settings

Returns current Web Push notification settings in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsWebpushGetRequest
*/
func (a *SettingsAPIService) SettingsNotificationsWebpushGet(ctx context.Context) SettingsAPISettingsNotificationsWebpushGetRequest {
	return SettingsAPISettingsNotificationsWebpushGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WebPushSettings
func (a *SettingsAPIService) SettingsNotificationsWebpushGetExecute(r SettingsAPISettingsNotificationsWebpushGetRequest) (*WebPushSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebPushSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsWebpushGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/webpush"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsWebpushPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	webPushSettings *WebPushSettings
}

func (r SettingsAPISettingsNotificationsWebpushPostRequest) WebPushSettings(webPushSettings WebPushSettings) SettingsAPISettingsNotificationsWebpushPostRequest {
	r.webPushSettings = &webPushSettings
	return r
}

func (r SettingsAPISettingsNotificationsWebpushPostRequest) Execute() (*WebPushSettings, *http.Response, error) {
	return r.ApiService.SettingsNotificationsWebpushPostExecute(r)
}

/*
SettingsNotificationsWebpushPost Update Web Push notification settings

Updates Web Push notification settings with the provided values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsWebpushPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsWebpushPost(ctx context.Context) SettingsAPISettingsNotificationsWebpushPostRequest {
	return SettingsAPISettingsNotificationsWebpushPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WebPushSettings
func (a *SettingsAPIService) SettingsNotificationsWebpushPostExecute(r SettingsAPISettingsNotificationsWebpushPostRequest) (*WebPushSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebPushSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsWebpushPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/webpush"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.webPushSettings == nil {
		return localVarReturnValue, nil, reportError("webPushSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webPushSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsNotificationsWebpushTestPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	webPushSettings *WebPushSettings
}

func (r SettingsAPISettingsNotificationsWebpushTestPostRequest) WebPushSettings(webPushSettings WebPushSettings) SettingsAPISettingsNotificationsWebpushTestPostRequest {
	r.webPushSettings = &webPushSettings
	return r
}

func (r SettingsAPISettingsNotificationsWebpushTestPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SettingsNotificationsWebpushTestPostExecute(r)
}

/*
SettingsNotificationsWebpushTestPost Test Web Push settings

Sends a test notification to the Web Push agent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsNotificationsWebpushTestPostRequest
*/
func (a *SettingsAPIService) SettingsNotificationsWebpushTestPost(ctx context.Context) SettingsAPISettingsNotificationsWebpushTestPostRequest {
	return SettingsAPISettingsNotificationsWebpushTestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SettingsAPIService) SettingsNotificationsWebpushTestPostExecute(r SettingsAPISettingsNotificationsWebpushTestPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsNotificationsWebpushTestPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications/webpush/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.webPushSettings == nil {
		return nil, reportError("webPushSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webPushSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SettingsAPISettingsPlexDevicesServersGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsPlexDevicesServersGetRequest) Execute() ([]PlexDevice, *http.Response, error) {
	return r.ApiService.SettingsPlexDevicesServersGetExecute(r)
}

/*
SettingsPlexDevicesServersGet Gets the user's available Plex servers

Returns a list of available Plex servers and their connectivity state

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsPlexDevicesServersGetRequest
*/
func (a *SettingsAPIService) SettingsPlexDevicesServersGet(ctx context.Context) SettingsAPISettingsPlexDevicesServersGetRequest {
	return SettingsAPISettingsPlexDevicesServersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PlexDevice
func (a *SettingsAPIService) SettingsPlexDevicesServersGetExecute(r SettingsAPISettingsPlexDevicesServersGetRequest) ([]PlexDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PlexDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsPlexDevicesServersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/plex/devices/servers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsPlexGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsPlexGetRequest) Execute() (*PlexSettings, *http.Response, error) {
	return r.ApiService.SettingsPlexGetExecute(r)
}

/*
SettingsPlexGet Get Plex settings

Retrieves current Plex settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsPlexGetRequest
*/
func (a *SettingsAPIService) SettingsPlexGet(ctx context.Context) SettingsAPISettingsPlexGetRequest {
	return SettingsAPISettingsPlexGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PlexSettings
func (a *SettingsAPIService) SettingsPlexGetExecute(r SettingsAPISettingsPlexGetRequest) (*PlexSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlexSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsPlexGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/plex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsPlexLibraryGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	sync *string
	enable *string
}

// Syncs the current libraries with the current Plex server
func (r SettingsAPISettingsPlexLibraryGetRequest) Sync(sync string) SettingsAPISettingsPlexLibraryGetRequest {
	r.sync = &sync
	return r
}

// Comma separated list of libraries to enable. Any libraries not passed will be disabled!
func (r SettingsAPISettingsPlexLibraryGetRequest) Enable(enable string) SettingsAPISettingsPlexLibraryGetRequest {
	r.enable = &enable
	return r
}

func (r SettingsAPISettingsPlexLibraryGetRequest) Execute() ([]PlexLibrary, *http.Response, error) {
	return r.ApiService.SettingsPlexLibraryGetExecute(r)
}

/*
SettingsPlexLibraryGet Get Plex libraries

Returns a list of Plex libraries in a JSON array.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsPlexLibraryGetRequest
*/
func (a *SettingsAPIService) SettingsPlexLibraryGet(ctx context.Context) SettingsAPISettingsPlexLibraryGetRequest {
	return SettingsAPISettingsPlexLibraryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PlexLibrary
func (a *SettingsAPIService) SettingsPlexLibraryGetExecute(r SettingsAPISettingsPlexLibraryGetRequest) ([]PlexLibrary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PlexLibrary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsPlexLibraryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/plex/library"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sync != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sync", r.sync, "")
	}
	if r.enable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enable", r.enable, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsPlexPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	plexSettings *PlexSettings
}

func (r SettingsAPISettingsPlexPostRequest) PlexSettings(plexSettings PlexSettings) SettingsAPISettingsPlexPostRequest {
	r.plexSettings = &plexSettings
	return r
}

func (r SettingsAPISettingsPlexPostRequest) Execute() (*PlexSettings, *http.Response, error) {
	return r.ApiService.SettingsPlexPostExecute(r)
}

/*
SettingsPlexPost Update Plex settings

Updates Plex settings with the provided values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsPlexPostRequest
*/
func (a *SettingsAPIService) SettingsPlexPost(ctx context.Context) SettingsAPISettingsPlexPostRequest {
	return SettingsAPISettingsPlexPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PlexSettings
func (a *SettingsAPIService) SettingsPlexPostExecute(r SettingsAPISettingsPlexPostRequest) (*PlexSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlexSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsPlexPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/plex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.plexSettings == nil {
		return localVarReturnValue, nil, reportError("plexSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.plexSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsPlexSyncGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsPlexSyncGetRequest) Execute() (*SettingsPlexSyncGet200Response, *http.Response, error) {
	return r.ApiService.SettingsPlexSyncGetExecute(r)
}

/*
SettingsPlexSyncGet Get status of full Plex library scan

Returns scan progress in a JSON array.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsPlexSyncGetRequest
*/
func (a *SettingsAPIService) SettingsPlexSyncGet(ctx context.Context) SettingsAPISettingsPlexSyncGetRequest {
	return SettingsAPISettingsPlexSyncGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SettingsPlexSyncGet200Response
func (a *SettingsAPIService) SettingsPlexSyncGetExecute(r SettingsAPISettingsPlexSyncGetRequest) (*SettingsPlexSyncGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SettingsPlexSyncGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsPlexSyncGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/plex/sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsPlexSyncPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	settingsPlexSyncPostRequest *SettingsPlexSyncPostRequest
}

func (r SettingsAPISettingsPlexSyncPostRequest) SettingsPlexSyncPostRequest(settingsPlexSyncPostRequest SettingsPlexSyncPostRequest) SettingsAPISettingsPlexSyncPostRequest {
	r.settingsPlexSyncPostRequest = &settingsPlexSyncPostRequest
	return r
}

func (r SettingsAPISettingsPlexSyncPostRequest) Execute() (*SettingsPlexSyncGet200Response, *http.Response, error) {
	return r.ApiService.SettingsPlexSyncPostExecute(r)
}

/*
SettingsPlexSyncPost Start full Plex library scan

Runs a full Plex library scan and returns the progress in a JSON array.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsPlexSyncPostRequest
*/
func (a *SettingsAPIService) SettingsPlexSyncPost(ctx context.Context) SettingsAPISettingsPlexSyncPostRequest {
	return SettingsAPISettingsPlexSyncPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SettingsPlexSyncGet200Response
func (a *SettingsAPIService) SettingsPlexSyncPostExecute(r SettingsAPISettingsPlexSyncPostRequest) (*SettingsPlexSyncGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SettingsPlexSyncGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsPlexSyncPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/plex/sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.settingsPlexSyncPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsPlexUsersGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsPlexUsersGetRequest) Execute() ([]SettingsPlexUsersGet200ResponseInner, *http.Response, error) {
	return r.ApiService.SettingsPlexUsersGetExecute(r)
}

/*
SettingsPlexUsersGet Get Plex users

Returns a list of Plex users in a JSON array.

Requires the `MANAGE_USERS` permission.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsPlexUsersGetRequest
*/
func (a *SettingsAPIService) SettingsPlexUsersGet(ctx context.Context) SettingsAPISettingsPlexUsersGetRequest {
	return SettingsAPISettingsPlexUsersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SettingsPlexUsersGet200ResponseInner
func (a *SettingsAPIService) SettingsPlexUsersGetExecute(r SettingsAPISettingsPlexUsersGetRequest) ([]SettingsPlexUsersGet200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SettingsPlexUsersGet200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsPlexUsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/plex/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsPublicGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsPublicGetRequest) Execute() (*PublicSettings, *http.Response, error) {
	return r.ApiService.SettingsPublicGetExecute(r)
}

/*
SettingsPublicGet Get public settings

Returns settings that are not protected or sensitive. Mainly used to determine if the application has been configured for the first time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsPublicGetRequest
*/
func (a *SettingsAPIService) SettingsPublicGet(ctx context.Context) SettingsAPISettingsPublicGetRequest {
	return SettingsAPISettingsPublicGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PublicSettings
func (a *SettingsAPIService) SettingsPublicGetExecute(r SettingsAPISettingsPublicGetRequest) (*PublicSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsPublicGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/public"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsRadarrGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsRadarrGetRequest) Execute() ([]RadarrSettings, *http.Response, error) {
	return r.ApiService.SettingsRadarrGetExecute(r)
}

/*
SettingsRadarrGet Get Radarr settings

Returns all Radarr settings in a JSON array.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsRadarrGetRequest
*/
func (a *SettingsAPIService) SettingsRadarrGet(ctx context.Context) SettingsAPISettingsRadarrGetRequest {
	return SettingsAPISettingsRadarrGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RadarrSettings
func (a *SettingsAPIService) SettingsRadarrGetExecute(r SettingsAPISettingsRadarrGetRequest) ([]RadarrSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RadarrSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsRadarrGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/radarr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsRadarrPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	radarrSettings *RadarrSettings
}

func (r SettingsAPISettingsRadarrPostRequest) RadarrSettings(radarrSettings RadarrSettings) SettingsAPISettingsRadarrPostRequest {
	r.radarrSettings = &radarrSettings
	return r
}

func (r SettingsAPISettingsRadarrPostRequest) Execute() (*RadarrSettings, *http.Response, error) {
	return r.ApiService.SettingsRadarrPostExecute(r)
}

/*
SettingsRadarrPost Create Radarr instance

Creates a new Radarr instance from the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsRadarrPostRequest
*/
func (a *SettingsAPIService) SettingsRadarrPost(ctx context.Context) SettingsAPISettingsRadarrPostRequest {
	return SettingsAPISettingsRadarrPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RadarrSettings
func (a *SettingsAPIService) SettingsRadarrPostExecute(r SettingsAPISettingsRadarrPostRequest) (*RadarrSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RadarrSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsRadarrPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/radarr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.radarrSettings == nil {
		return localVarReturnValue, nil, reportError("radarrSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.radarrSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsRadarrRadarrIdDeleteRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	radarrId int32
}

func (r SettingsAPISettingsRadarrRadarrIdDeleteRequest) Execute() (*RadarrSettings, *http.Response, error) {
	return r.ApiService.SettingsRadarrRadarrIdDeleteExecute(r)
}

/*
SettingsRadarrRadarrIdDelete Delete Radarr instance

Deletes an existing Radarr instance based on the radarrId parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param radarrId Radarr instance ID
 @return SettingsAPISettingsRadarrRadarrIdDeleteRequest
*/
func (a *SettingsAPIService) SettingsRadarrRadarrIdDelete(ctx context.Context, radarrId int32) SettingsAPISettingsRadarrRadarrIdDeleteRequest {
	return SettingsAPISettingsRadarrRadarrIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		radarrId: radarrId,
	}
}

// Execute executes the request
//  @return RadarrSettings
func (a *SettingsAPIService) SettingsRadarrRadarrIdDeleteExecute(r SettingsAPISettingsRadarrRadarrIdDeleteRequest) (*RadarrSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RadarrSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsRadarrRadarrIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/radarr/{radarrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"radarrId"+"}", url.PathEscape(parameterValueToString(r.radarrId, "radarrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsRadarrRadarrIdProfilesGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	radarrId int32
}

func (r SettingsAPISettingsRadarrRadarrIdProfilesGetRequest) Execute() ([]ServiceProfile, *http.Response, error) {
	return r.ApiService.SettingsRadarrRadarrIdProfilesGetExecute(r)
}

/*
SettingsRadarrRadarrIdProfilesGet Get available Radarr profiles

Returns a list of profiles available on the Radarr server instance in a JSON array.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param radarrId Radarr instance ID
 @return SettingsAPISettingsRadarrRadarrIdProfilesGetRequest
*/
func (a *SettingsAPIService) SettingsRadarrRadarrIdProfilesGet(ctx context.Context, radarrId int32) SettingsAPISettingsRadarrRadarrIdProfilesGetRequest {
	return SettingsAPISettingsRadarrRadarrIdProfilesGetRequest{
		ApiService: a,
		ctx: ctx,
		radarrId: radarrId,
	}
}

// Execute executes the request
//  @return []ServiceProfile
func (a *SettingsAPIService) SettingsRadarrRadarrIdProfilesGetExecute(r SettingsAPISettingsRadarrRadarrIdProfilesGetRequest) ([]ServiceProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ServiceProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsRadarrRadarrIdProfilesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/radarr/{radarrId}/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"radarrId"+"}", url.PathEscape(parameterValueToString(r.radarrId, "radarrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsRadarrRadarrIdPutRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	radarrId int32
	radarrSettings *RadarrSettings
}

func (r SettingsAPISettingsRadarrRadarrIdPutRequest) RadarrSettings(radarrSettings RadarrSettings) SettingsAPISettingsRadarrRadarrIdPutRequest {
	r.radarrSettings = &radarrSettings
	return r
}

func (r SettingsAPISettingsRadarrRadarrIdPutRequest) Execute() (*RadarrSettings, *http.Response, error) {
	return r.ApiService.SettingsRadarrRadarrIdPutExecute(r)
}

/*
SettingsRadarrRadarrIdPut Update Radarr instance

Updates an existing Radarr instance with the provided values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param radarrId Radarr instance ID
 @return SettingsAPISettingsRadarrRadarrIdPutRequest
*/
func (a *SettingsAPIService) SettingsRadarrRadarrIdPut(ctx context.Context, radarrId int32) SettingsAPISettingsRadarrRadarrIdPutRequest {
	return SettingsAPISettingsRadarrRadarrIdPutRequest{
		ApiService: a,
		ctx: ctx,
		radarrId: radarrId,
	}
}

// Execute executes the request
//  @return RadarrSettings
func (a *SettingsAPIService) SettingsRadarrRadarrIdPutExecute(r SettingsAPISettingsRadarrRadarrIdPutRequest) (*RadarrSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RadarrSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsRadarrRadarrIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/radarr/{radarrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"radarrId"+"}", url.PathEscape(parameterValueToString(r.radarrId, "radarrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.radarrSettings == nil {
		return localVarReturnValue, nil, reportError("radarrSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.radarrSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsRadarrTestPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	settingsRadarrTestPostRequest *SettingsRadarrTestPostRequest
}

func (r SettingsAPISettingsRadarrTestPostRequest) SettingsRadarrTestPostRequest(settingsRadarrTestPostRequest SettingsRadarrTestPostRequest) SettingsAPISettingsRadarrTestPostRequest {
	r.settingsRadarrTestPostRequest = &settingsRadarrTestPostRequest
	return r
}

func (r SettingsAPISettingsRadarrTestPostRequest) Execute() (*SettingsRadarrTestPost200Response, *http.Response, error) {
	return r.ApiService.SettingsRadarrTestPostExecute(r)
}

/*
SettingsRadarrTestPost Test Radarr configuration

Tests if the Radarr configuration is valid. Returns profiles and root folders on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsRadarrTestPostRequest
*/
func (a *SettingsAPIService) SettingsRadarrTestPost(ctx context.Context) SettingsAPISettingsRadarrTestPostRequest {
	return SettingsAPISettingsRadarrTestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SettingsRadarrTestPost200Response
func (a *SettingsAPIService) SettingsRadarrTestPostExecute(r SettingsAPISettingsRadarrTestPostRequest) (*SettingsRadarrTestPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SettingsRadarrTestPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsRadarrTestPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/radarr/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.settingsRadarrTestPostRequest == nil {
		return localVarReturnValue, nil, reportError("settingsRadarrTestPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.settingsRadarrTestPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsSonarrGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsSonarrGetRequest) Execute() ([]SonarrSettings, *http.Response, error) {
	return r.ApiService.SettingsSonarrGetExecute(r)
}

/*
SettingsSonarrGet Get Sonarr settings

Returns all Sonarr settings in a JSON array.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsSonarrGetRequest
*/
func (a *SettingsAPIService) SettingsSonarrGet(ctx context.Context) SettingsAPISettingsSonarrGetRequest {
	return SettingsAPISettingsSonarrGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SonarrSettings
func (a *SettingsAPIService) SettingsSonarrGetExecute(r SettingsAPISettingsSonarrGetRequest) ([]SonarrSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SonarrSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsSonarrGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/sonarr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsSonarrPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	sonarrSettings *SonarrSettings
}

func (r SettingsAPISettingsSonarrPostRequest) SonarrSettings(sonarrSettings SonarrSettings) SettingsAPISettingsSonarrPostRequest {
	r.sonarrSettings = &sonarrSettings
	return r
}

func (r SettingsAPISettingsSonarrPostRequest) Execute() (*SonarrSettings, *http.Response, error) {
	return r.ApiService.SettingsSonarrPostExecute(r)
}

/*
SettingsSonarrPost Create Sonarr instance

Creates a new Sonarr instance from the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsSonarrPostRequest
*/
func (a *SettingsAPIService) SettingsSonarrPost(ctx context.Context) SettingsAPISettingsSonarrPostRequest {
	return SettingsAPISettingsSonarrPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SonarrSettings
func (a *SettingsAPIService) SettingsSonarrPostExecute(r SettingsAPISettingsSonarrPostRequest) (*SonarrSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SonarrSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsSonarrPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/sonarr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sonarrSettings == nil {
		return localVarReturnValue, nil, reportError("sonarrSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sonarrSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsSonarrSonarrIdDeleteRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	sonarrId int32
}

func (r SettingsAPISettingsSonarrSonarrIdDeleteRequest) Execute() (*SonarrSettings, *http.Response, error) {
	return r.ApiService.SettingsSonarrSonarrIdDeleteExecute(r)
}

/*
SettingsSonarrSonarrIdDelete Delete Sonarr instance

Deletes an existing Sonarr instance based on the sonarrId parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sonarrId Sonarr instance ID
 @return SettingsAPISettingsSonarrSonarrIdDeleteRequest
*/
func (a *SettingsAPIService) SettingsSonarrSonarrIdDelete(ctx context.Context, sonarrId int32) SettingsAPISettingsSonarrSonarrIdDeleteRequest {
	return SettingsAPISettingsSonarrSonarrIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		sonarrId: sonarrId,
	}
}

// Execute executes the request
//  @return SonarrSettings
func (a *SettingsAPIService) SettingsSonarrSonarrIdDeleteExecute(r SettingsAPISettingsSonarrSonarrIdDeleteRequest) (*SonarrSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SonarrSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsSonarrSonarrIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/sonarr/{sonarrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sonarrId"+"}", url.PathEscape(parameterValueToString(r.sonarrId, "sonarrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsSonarrSonarrIdPutRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	sonarrId int32
	sonarrSettings *SonarrSettings
}

func (r SettingsAPISettingsSonarrSonarrIdPutRequest) SonarrSettings(sonarrSettings SonarrSettings) SettingsAPISettingsSonarrSonarrIdPutRequest {
	r.sonarrSettings = &sonarrSettings
	return r
}

func (r SettingsAPISettingsSonarrSonarrIdPutRequest) Execute() (*SonarrSettings, *http.Response, error) {
	return r.ApiService.SettingsSonarrSonarrIdPutExecute(r)
}

/*
SettingsSonarrSonarrIdPut Update Sonarr instance

Updates an existing Sonarr instance with the provided values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sonarrId Sonarr instance ID
 @return SettingsAPISettingsSonarrSonarrIdPutRequest
*/
func (a *SettingsAPIService) SettingsSonarrSonarrIdPut(ctx context.Context, sonarrId int32) SettingsAPISettingsSonarrSonarrIdPutRequest {
	return SettingsAPISettingsSonarrSonarrIdPutRequest{
		ApiService: a,
		ctx: ctx,
		sonarrId: sonarrId,
	}
}

// Execute executes the request
//  @return SonarrSettings
func (a *SettingsAPIService) SettingsSonarrSonarrIdPutExecute(r SettingsAPISettingsSonarrSonarrIdPutRequest) (*SonarrSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SonarrSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsSonarrSonarrIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/sonarr/{sonarrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sonarrId"+"}", url.PathEscape(parameterValueToString(r.sonarrId, "sonarrId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sonarrSettings == nil {
		return localVarReturnValue, nil, reportError("sonarrSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sonarrSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsSonarrTestPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	settingsSonarrTestPostRequest *SettingsSonarrTestPostRequest
}

func (r SettingsAPISettingsSonarrTestPostRequest) SettingsSonarrTestPostRequest(settingsSonarrTestPostRequest SettingsSonarrTestPostRequest) SettingsAPISettingsSonarrTestPostRequest {
	r.settingsSonarrTestPostRequest = &settingsSonarrTestPostRequest
	return r
}

func (r SettingsAPISettingsSonarrTestPostRequest) Execute() (*SettingsRadarrTestPost200Response, *http.Response, error) {
	return r.ApiService.SettingsSonarrTestPostExecute(r)
}

/*
SettingsSonarrTestPost Test Sonarr configuration

Tests if the Sonarr configuration is valid. Returns profiles and root folders on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsSonarrTestPostRequest
*/
func (a *SettingsAPIService) SettingsSonarrTestPost(ctx context.Context) SettingsAPISettingsSonarrTestPostRequest {
	return SettingsAPISettingsSonarrTestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SettingsRadarrTestPost200Response
func (a *SettingsAPIService) SettingsSonarrTestPostExecute(r SettingsAPISettingsSonarrTestPostRequest) (*SettingsRadarrTestPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SettingsRadarrTestPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsSonarrTestPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/sonarr/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.settingsSonarrTestPostRequest == nil {
		return localVarReturnValue, nil, reportError("settingsSonarrTestPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.settingsSonarrTestPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsTautulliGetRequest struct {
	ctx context.Context
	ApiService SettingsAPI
}

func (r SettingsAPISettingsTautulliGetRequest) Execute() (*TautulliSettings, *http.Response, error) {
	return r.ApiService.SettingsTautulliGetExecute(r)
}

/*
SettingsTautulliGet Get Tautulli settings

Retrieves current Tautulli settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsTautulliGetRequest
*/
func (a *SettingsAPIService) SettingsTautulliGet(ctx context.Context) SettingsAPISettingsTautulliGetRequest {
	return SettingsAPISettingsTautulliGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TautulliSettings
func (a *SettingsAPIService) SettingsTautulliGetExecute(r SettingsAPISettingsTautulliGetRequest) (*TautulliSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TautulliSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsTautulliGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/tautulli"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SettingsAPISettingsTautulliPostRequest struct {
	ctx context.Context
	ApiService SettingsAPI
	tautulliSettings *TautulliSettings
}

func (r SettingsAPISettingsTautulliPostRequest) TautulliSettings(tautulliSettings TautulliSettings) SettingsAPISettingsTautulliPostRequest {
	r.tautulliSettings = &tautulliSettings
	return r
}

func (r SettingsAPISettingsTautulliPostRequest) Execute() (*TautulliSettings, *http.Response, error) {
	return r.ApiService.SettingsTautulliPostExecute(r)
}

/*
SettingsTautulliPost Update Tautulli settings

Updates Tautulli settings with the provided values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SettingsAPISettingsTautulliPostRequest
*/
func (a *SettingsAPIService) SettingsTautulliPost(ctx context.Context) SettingsAPISettingsTautulliPostRequest {
	return SettingsAPISettingsTautulliPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TautulliSettings
func (a *SettingsAPIService) SettingsTautulliPostExecute(r SettingsAPISettingsTautulliPostRequest) (*TautulliSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TautulliSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsAPIService.SettingsTautulliPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/tautulli"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tautulliSettings == nil {
		return localVarReturnValue, nil, reportError("tautulliSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tautulliSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
